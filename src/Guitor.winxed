#! winxed

// Guitor.winxed

// Xlib module via parrot NCI.

$include "GuitorConstants.winxhead";

$include_const "hash_key_type.pasm";

$load "GuitorNci.pbc";

namespace Guitor
{

$include_const "datatypes.pasm";

//**************************************************************
//                 Internal helper functions
//**************************************************************

namespace Xlib__private
{

extern function str_to_achar_utf8;
extern function str_to_cstring;
extern function string_from_nci;
extern function getfun;
extern function getxftfun;
extern function geteventpad;
extern function getanyview;
extern function getstructureview;
extern function getexposeview;
extern function getfocusview;
extern function getmotionview;
extern function getbuttonview;
extern function getkeyview;
extern function getclientview;
extern function getxcolorview;
extern function getxftcolorview;
extern function getxftfontview;
extern function getxfontview;
extern function getatomview;
extern function getglyphinfoview;
extern function getview;

extern function newAtomlist;

function Free(p)
{
    getfun("XFree")(p);
}

} // namespace Xlib__private

using namespace Xlib__private;
using namespace Events;


//**************************************************************
//                       Display
//**************************************************************

class Display
{
    var xdisplay;
    var default_screen;
    var default_font;
    var xim;

    function Display(string displayname[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var d;
        if (displayname == null)
            displayname = "";
        d = str_to_cstring(displayname);
        self.xdisplay = getfun("XOpenDisplay")(d);
        getfun("setlocale")(0, str_to_cstring(""));
        getfun("XSetLocaleModifiers")(str_to_cstring(""));
        self.default_screen = self._DefaultScreen();
    }
    function Close()
    {
        __DEBUG__ && cry("Display.Close");
        getfun("XCloseDisplay")(self.xdisplay);
        self.xdisplay = null;
        __DEBUG__ && cry("closed");
    }
    function Flush()
    {
        getfun("XFlush")(self.xdisplay);
    }
    function _DefaultScreen()
    {
        int scrnum = getfun("XDefaultScreen")(self.xdisplay);
        return scrnum;
    }
    function DefaultScreen()
    {
        return int(self.default_screen);
    }
    function DefaultDepth(int scrnum)
    {
        int depth = getfun("XDefaultDepth")(self.xdisplay, scrnum);
        return depth;
    }
    function DefaultVisual(int scrnum[optional])
    {
        return getfun("XDefaultVisual")(self.xdisplay, scrnum);
    }
    function DefaultColormap(int scrnum[optional])
    {
        return getfun("XDefaultColormap")(self.xdisplay, scrnum);
    }
    function Height(int scrnum[optional])
    {
        return int(getfun("XDisplayHeight")(self.xdisplay, scrnum));
    }
    function HeightMM(int scrnum[optional])
    {
        return int(getfun("XDisplayHeightMM")(self.xdisplay, scrnum));
    }
    function Width(int scrnum[optional])
    {
        return int(getfun("XDisplayWidth")(self.xdisplay, scrnum));
    }
    function WidthMM(int scrnum[optional])
    {
        return int(getfun("XDisplayWidthMM")(self.xdisplay, scrnum));
    }
    function BlackPixel(int scrnum)
    {
        return getfun("XBlackPixel")(self.xdisplay, scrnum);
    }
    function WhitePixel(int scrnum)
    {
        return getfun("XWhitePixel")(self.xdisplay, scrnum);
    }
    function KeycodeToKeysym(int keycode)
    {
        return getfun("XKeycodeToKeysym")(self.xdisplay, keycode, 0);
    }
    function KeysymToKeycode(int keysym)
    {
        return getfun("XKeysymToKeycode")(self.xdisplay, keysym);
    }
    function StringToKeysym(string keystring)
    {
        return getfun("XStringToKeysym")(str_to_cstring(keystring));
    }
    function KeysymToString(int keysym)
    {
        var fn = getfun("XKeysymToString");
        return string_from_nci(fn(keysym));
    }
    function getIM()
    {
        var xim = self.xim;
        if (self.xim == null) {
            xim = getfun("XOpenIM")(self.xdisplay, null, null, null);
            if (! xim)
                xim = false;
            self.xim = xim;
        }
        return xim;
    }
    function _LookupString(window, event)
    {
        const int BUFSIZE = 32;
        var buffer = new ["ByteBuffer"];
        buffer =: BUFSIZE;
        int len;
        var fun;
        var xic = window.getIC();
        if (xic == null || ! xic) {
            fun = getfun("XLookupString");
            len = fun(event.eventdata, buffer, BUFSIZE, null, null);
        }
        else {
            fun = getfun("XmbLookupString");
            len = fun(xic, event.eventdata, buffer, BUFSIZE, null, null);
        }
        string str;
        if (len > 0) {
            buffer =: len;
            str = buffer.get_string("utf8");
        }
        return str;
    }
    function InternAtom(string name, int only_if_exists[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var pname = str_to_cstring(name);
        int atom = getfun("XInternAtom")(self.xdisplay, pname, only_if_exists);
        return atom;
    }
    function GetAtomName(int atom)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var name = getfun("XGetAtomName")(self.xdisplay, atom);
        string sname = name.as_string("ascii");
        Free(name);
        return sname;
    }
    function AtomlistFromStrings(var atomnames)
    {
        __DEBUG__ && cry(__FUNCTION__);
        int natoms = elements(atomnames);
        var aux = newAtomlist(natoms);
        var ast = getatomview(elements(atomnames));
        for (int i = 0; i < natoms; ++i)
            ast[aux, i] = int(self.InternAtom(atomnames[i]));
        return aux;
    }
    function DefaultGC()
    {
        var fn = getfun("XDefaultGC");
        return fn(self.xdisplay, self.default_screen);
    }
    function _RootWindow(int scrnum)
    {
        __DEBUG__ && cry(__FUNCTION__);
        return getfun("XRootWindow")(self.xdisplay, scrnum);
    }
    function RootWindow(int scrnum)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XRootWindow");
        var rootw = new Window;
        rootw.display = self;
        rootw.xdrawable = fn(self.xdisplay, scrnum);
        return rootw;
    }
    function CreateSimpleWindow(var parent,
        int x, int y, int width, int height,
        int border_width, int border, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, parent.xdrawable,
                x, y, width, height, border_width, border, background);
    }
    function CreateSimpleWindow(int x, int y, int width, int height,
        int border_width, int border, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, self._RootWindow(0),
                x, y, width, height, border_width, border, background);
    }
    function CreateSimpleWindow(int x, int y, int width, int height)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, self._RootWindow(0), x, y, width, height,
                0, self.BlackPixel(0), self.WhitePixel(0));
    }
    function CreateSimpleChildWindow(parent, x, y, width, height,
            int border_width, int border_color, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, parent.xdrawable, x, y, width, height,
                border_width, border_color, background);
    }
    function NextEvent(var event)
    {
        using namespace Events;
        var fn = getfun("XNextEvent");
        event._get(self.xdisplay, fn);
    }
    function SetWMProtocols(drawable, names)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var atomlist = self.AtomlistFromStrings(names);
        var fn = getfun("XSetWMProtocols");
        fn(self.xdisplay, drawable.xdrawable, atomlist, elements(names));
    }

    function ParseColor(string spec)
    {
        var xdisplay = self.xdisplay;
        var colormap = self.DefaultColormap();
/*
        var xcolorview = getxcolorview();
        var xcolor = xcolorview.alloc();
        int status = getfun("XParseColor")(xdisplay, colormap, str_to_cstring(spec), xcolor);
        if (status) {
            status = getfun("XAllocColor")(xdisplay, colormap, xcolor);
            if (status)
                return new Color(xcolor);
        }
*/
        var xftcolorview = getxftcolorview();
        var xftcolor = xftcolorview.alloc();
        var visual = self.DefaultVisual();
        if (getxftfun("XftColorAllocName")(xdisplay, visual, colormap,
                str_to_cstring(spec), xftcolor)) {
            var color = new XftColor;
            color.xftcolor = xftcolor;
            return color;
        }

        return null;
    }
    function setDefaultFont(string fontdesc)
    {
        var font = self.default_font;
        if (font == null) {
            var ptr = new ["StructView"]( [DATATYPE_STRUCT, 1, DATATYPE_PTR ] );
            var p1 = ptr.alloc();
            var p2 = ptr.alloc();
            var p3 = ptr.alloc();
            var xfont = getfun("XCreateFontSet")(self.xdisplay,
                    str_to_cstring(fontdesc), p1, p2, p3);
            if (xfont == null || ! xfont)
                return false;
            font = new FontSet;
            font.xfont = xfont;
        }
        self.default_font = font;
        return true;
    }
    function getDefaultFont()
    {
        var font = self.default_font;
        if (font == null) {
            self.setDefaultFont("-*-*-*-r-*-*-*-140-*");
            font = self.default_font;
        }
        return font;
    }
    function CreateFont(string name)
    {
        var xdisplay = self.xdisplay;
        var pname = str_to_cstring(name);
        var fun = getxftfun("XftFontOpenXlfd");
        if (fun == null)
            throw "Xft not available";
        var xftfont = fun(xdisplay, 0, pname);
        if (xftfont == null) {
            xftfont = getxftfun("XftFontOpenName")(xdisplay, 0, pname);
            if (xftfont == null)
                return null;
        }
        var font = new XftFont;
        font.xftfont = xftfont;
        return font;
    }
}

//**********************************************************************

class Color
{
    var xcolor;
    function Color(xcolor)
    {
        self.xcolor = xcolor;
    }
    function pixel()
    {
        var xcolorview = getxcolorview();
        return int(xcolorview[self.xcolor, 0]);
    }
}

class XftColor
{
    var xftcolor;
    function pixel()
    {
        var xftcolorview = getxftcolorview();
        int pixel = xftcolorview[self.xftcolor, 0];
        return pixel;
    }
}

//**********************************************************************

class FontSet
{
    var xfont;
    function DrawString(display, drawable, int x, int y, string str)
    {
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        getfun("XmbDrawString")(display.xdisplay, drawable.xdrawable,
            self.xfont, drawable.getgc().xgc, x, y, pstr, len);
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        getfun("XmbDrawImageString")(display.xdisplay, drawable.xdrawable,
            self.xfont, drawable.getgc().xgc, x, y, pstr, len);
    }
    function getHeight()
    {
        var view = getxfontview();
        return int(view[self.xfont, 22]) + int(view[self.xfont, 23]);
    }
    function getTextWidth(display, string text)
    {
        return int(getfun("XmbTextEscapement")(self.xfont, str_to_cstring(text), bytelength(text)));
    }
}

class XftFont
{
    var xftfont;
    function DrawString(display, drawable, int x, int y, string str)
    {
        if (length(str) == 0)
            return;

        var visual = display.DefaultVisual();
        var colormap = display.DefaultColormap();
        var xdisplay = display.xdisplay;
        var xdrawable = drawable.xdrawable;
        var color = getxftcolorview().alloc();
        getxftfun("XftColorAllocName")(xdisplay, visual, colormap,
                str_to_cstring("black"), color);
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        var xftdraw = getxftfun("XftDrawCreate")(xdisplay, xdrawable,
                visual, colormap);
        getxftfun("XftDrawStringUtf8")(xftdraw, color, self.xftfont,
            x, y, pstr, len);
        getxftfun("XftDrawDestroy")(xftdraw);
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        if (length(str) == 0)
            return;
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);

        var xdisplay = display.xdisplay;
        var xdrawable = drawable.xdrawable;
        var xftfont = self.xftfont;
        var fview = getxftfontview();
        int ascent = fview[xftfont, 0];
        var tview = getglyphinfoview();
        var glyphinfo = tview.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, xftfont,
                pstr, len, glyphinfo);
        int top  = y - tview[glyphinfo, 3];
        int left = x - tview[glyphinfo, 2];
        int width = tview[glyphinfo, 0];
        int height = tview[glyphinfo, 1];

        var visual = display.DefaultVisual();
        var colormap = display.DefaultColormap();
        var xftdraw = getxftfun("XftDrawCreate")(xdisplay, xdrawable,
                visual, colormap);

        var gc = drawable.getgc();
        var xcolor;
        var color = gc.getForeground();
        if (color != null)
            xcolor = color.xftcolor;
        if (xcolor == null) {
            color = display.ParseColor("black");
            xcolor = color.xftcolor;
        }

        var xbgcolor;
        var bgcolor = gc.getBackground();
        if (bgcolor != null)
            xbgcolor = bgcolor.xftcolor;
        if (xbgcolor == null) {
            bgcolor = display.ParseColor("white");
            xbgcolor = bgcolor.xftcolor;
        }

        getxftfun("XftDrawRect")(xftdraw, xbgcolor, left, top, width, height);
        getxftfun("XftDrawStringUtf8")(xftdraw, xcolor, xftfont,
            x, y, pstr, len);
        getxftfun("XftDrawDestroy")(xftdraw);
    }
    function getAscent()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 0]);
    }
    function getDescent()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 1]);
    }
    function getHeight()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 2]);
    }
    function getTextWidth(display, string text)
    {
        var pstr = str_to_achar_utf8(text);
        int len = elements(pstr);
        var view = getglyphinfoview();
        var glyphinfo = view.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, self.xftfont,
                pstr, len, glyphinfo);
        return int(view[glyphinfo, 0]);
    }
    function getTextxOff(display, string text)
    {
        var pstr = str_to_achar_utf8(text);
        int len = elements(pstr);
        var view = getglyphinfoview();
        var glyphinfo = view.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, self.xftfont,
                pstr, len, glyphinfo);
        return int(view[glyphinfo, 4]);
    }
}

//**********************************************************************

function DisplayName()
{
    var fn = getfun("XDisplayName");
    return string_from_nci(fn(null));
}

function KeysymToString(int keysym)
{
    var fn = getfun("XKeysymToString");
    return string_from_nci(fn(keysym));
}

function StringToKeysym(string keystring)
{
    var fn = getfun("XStringToKeysym");
    var pkey = str_to_cstring(keystring);
    int k = fn(pkey);
    return k;
}

function OpenDisplay(string displayname[optional])
{
    return new Display(displayname);
}

//**************************************************************
//                        Event
//**************************************************************

class Event
{
    var eventdata;
    var anyview;
    var evtype;
    var evx;
    var evy;
    var evx_root;
    var evy_root;
    var evwidth;
    var evheight;
    var evkeycode;
    var evbutton;
    function Event()
    {
        self.eventdata = geteventpad().alloc();
        self.anyview = getanyview();
        self.evtype = 0;
        self.evx = 0;
        self.evy = 0;
        self.evx_root = 0;
        self.evy_root = 0;
        self.evwidth = 0;
        self.evheight = 0;
        self.evkeycode = -1;
        self.evbutton = 0;
    }
    function _get(xdisplay, fn)
    {
        var eventdata = self.eventdata;
        fn(xdisplay, eventdata);
        var view = self.anyview;
        int type = view[self.eventdata, 0];
        self.evtype =: type;
        int x = 0, y = 0, x_root = 0, y_root = 0,
                width = 0, height = 0,
                keycode = -1, button = 0;
        switch (type) {
          case ConfigureNotify:
            view   = getstructureview();
            x      = view[eventdata, 6];
            y      = view[eventdata, 7];
            width  = view[eventdata, 8];
            height = view[eventdata, 9];
            break;
          case Expose:
            view   = getexposeview();
            x      = view[eventdata, 5];
            y      = view[eventdata, 6];
            width  = view[eventdata, 7];
            height = view[eventdata, 8];
            break;
          case KeyPress:
            view    = getkeyview();
            x       = view[eventdata, 8];
            y       = view[eventdata, 9];
            x_root  = view[eventdata, 10];
            y_root  = view[eventdata, 11];
            keycode = view[eventdata, 13];
            break;
          case ButtonPress:
          case ButtonRelease:
            view   = getbuttonview();
            x      = view[eventdata, 8];
            y      = view[eventdata, 9];
            x_root = view[eventdata, 10];
            y_root = view[eventdata, 11];
            button = view[eventdata, 13];
            break;
          case MotionNotify:
            view   = getmotionview();
            x      = view[eventdata, 8];
            y      = view[eventdata, 9];
            x_root = view[eventdata, 10];
            y_root = view[eventdata, 11];
            break;
          case FocusIn:
          case FocusOut:
            view   = getfocusview();
            break;
        }
        self.evx =: x;
        self.evy =: y;
        self.evx_root =: x_root;
        self.evy_root =: y_root;
        self.evwidth =: width;
        self.evheight =: height;
        self.evkeycode =: keycode;
        self.evbutton =: button;
    }
    function type()
    {
        return int(self.evtype);
    }
    function serial()
    {
        int t = self.anyview[self.eventdata, 1];
        return t;
    }
    function window()
    {
        int t = self.anyview[self.eventdata, 4];
        return t;
    }
    function time()
    {
        int t = self.anyview[self.eventdata, 7];
        return t;
    }
    function x()
    {
        return int(self.evx);
    }
    function y()
    {
        return int(self.evy);
    }
    function x_root()
    {
        return int(self.evx_root);
    }
    function y_root()
    {
        return int(self.evy_root);
    }
    function width()
    {
        return int(self.evwidth);
    }
    function height()
    {
        return int(self.evheight);
    }
    function keycode()
    {
        return int(self.evkeycode);
    }
    function keyname()
    {
        int keycode = self.evkeycode;
        string key;
        if (keycode >= 0) {
            var xdisplay = self.anyview[self.eventdata, 3];
            int keysym = getfun("XKeycodeToKeysym")(xdisplay, keycode, 0);
            key = KeysymToString(keysym);
        }
        return key;
    }
    function button()
    {
        return int(self.evbutton);
    }
    function message_type()
    {
        int type = 0;
        if (self.evtype == ClientMessage) {
            var view = getclientview();
            type = view[self.eventdata, 5];
        }
        return type;
    }
    function message_data(int n)
    {
        int data = 0;
        if (self.evtype == ClientMessage) {
            var view = getclientview();
            data = view[self.eventdata, 7 + n];
        }
        return data;
    }
}

//**************************************************************
//                      GC
//**************************************************************

class GraphicContext
{
    var display;
    var xgc;
    var color;
    var bgcolor;
    var font;
    function GraphicContext(display)
    {
        self.display = display;
        self.xgc = display.DefaultGC();
    }
    function GraphicContext(display, drawable)
    {
        self.display = display;
        self.xgc = getfun("XCreateGC")
                (display.xdisplay, drawable.xdrawable, null, 0);
    }

    function SetForeground(string spec)
    {
        var color = self.display.ParseColor(spec);
        if (color != null) {
            self.color = color;
            getfun("XSetForeground")(self.display.xdisplay, self.xgc, color.pixel());
        }
    }
    function SetForeground [multi("_", "String")] (spec)
    {
        self.SetForeground(string(spec));
    }
    function SetForeground(var color)
    {
        self.color = color;
        getfun("XSetForeground")(self.display.xdisplay, self.xgc, color.pixel());
    }
    function SetBackground(string spec)
    {
        var color = self.display.ParseColor(spec);
        if (color != null)  {
            self.bgcolor = color;
            getfun("XSetBackground")(self.display.xdisplay, self.xgc, color.pixel());
        }
    }
    function SetBackground [multi("_", "String")] (spec)
    {
        self.SetBackground(string(spec));
    }
    function SetBackground(var color)
    {
        self.bgcolor = color;
        getfun("XSetBackground")(self.display.xdisplay, self.xgc, color.pixel());
    }
    function getForeground()
    {
        return self.color;
    }
    function getBackground()
    {
        return self.bgcolor;
    }
    function SetFunction(display, int func)
    {
        getfun("XSetFunction")(display.xdisplay, self.xgc, func);
    }
    function SetLineAttributes(display, int width,
            int style, int cap, int join)
    {
        getfun("XSetLineAttributes")(display.xdisplay, self.xgc,
                width, style, cap, join);
    }
    function SetSubwindowMode(display, int mode)
    {
        getfun("XSetSubwindowMode")(display.xdisplay, self.xgc, mode);
    }

    function DrawPoint(display, drawable, int x, int y)
    {
        getfun("XDrawPoint")(display.xdisplay, drawable.xdrawable,
                self.xgc, x, y);
    }
    function DrawLine(display, drawable, int x1, int y1, int x2, int y2)
    {
        getfun("XDrawLine")(display.xdisplay, drawable.xdrawable,
                self.xgc, x1, y1, x2, y2);
    }
    function DrawRectangle(display, drawable,
            int x, int y, int width, int height)
    {
        getfun("XDrawRectangle")(display.xdisplay, drawable.xdrawable,
                self.xgc, x, y, width, height);
    }
    function FillRectangle(display, drawable,
            int x, int y, int width, int height)
    {
        getfun("XFillRectangle")(display.xdisplay, drawable.xdrawable,
                self.xgc, x, y, width, height);
    }

    function DrawString(display, drawable, int x, int y, string str)
    {
        var font = drawable.font;
        if (font == null)
            font = display.getDefaultFont();
        if (font != null)
            font.DrawString(display, drawable, x, y, str);
        else {
            var xgc = self.xgc;
            var pstr = str_to_achar_utf8(str);
            int len = elements(pstr);
            getfun("XDrawString")(display.xdisplay, drawable.xdrawable,
                    xgc, x, y, pstr, len);
        }
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        var font = drawable.font;
        if (font == null)
            font = display.getDefaultFont();
        if (font != null)
            font.DrawImageString(display, drawable, x, y, str);
        else {
            var xgc = self.xgc;
            var pstr = str_to_achar_utf8(str);
            int len = elements(pstr);
            getfun("XDrawImageString")(display.xdisplay, drawable.xdrawable,
                    xgc, x, y, pstr, len);
        }
    }
}

//**************************************************************
//                      Drawable
//**************************************************************

class Drawable
{
    var display;
    var xdrawable;
    var gc;
    var font;
    function getgc()
    {
        var gc = self.gc;
        if (gc == null)
            gc = new GraphicContext(self.display);
        return gc;
    }
    function owngc()
    {
        var gc = self.gc;
        if (gc == null)
            self.gc = gc = new GraphicContext(self.display, self);
        return gc;
    }
    function SetForeground(string spec)
    {
        self.owngc().SetForeground(spec);
    }
    function SetForeground(var color)
    {
        self.owngc().SetForeground(color);
    }
    function SetBackground(string spec)
    {
        self.owngc().SetBackground(spec);
    }
    function SetBackground(var color)
    {
        self.owngc().SetBackground(color);
    }
    function SetFont(font)
    {
        self.font = font;
    }
    function DrawPoint(int x, int y)
    {
        self.getgc().DrawPoint(self.display, self, x, y);
    }
    function DrawLine(int x1, int y1, int x2, int y2)
    {
        self.getgc().DrawLine(self.display, self, x1, y1, x2, y2);
    }
    function DrawRectangle(int x, int y, int width, int height)
    {
        self.getgc().DrawRectangle(self.display, self, x, y, width, height);
    }
    function FillRectangle(int x, int y, int width, int height)
    {
        self.getgc().FillRectangle(self.display, self, x, y, width, height);
    }
    function SetFunction(int func)
    {
        self.owngc().SetFunction(self.display, func);
    }
    function SetLineAttributes(int width, int style, int cap, int join)
    {
        self.owngc().SetLineAttributes(self.display, width, style, cap, join);
    }
    function SetSubwindowMode(int mode)
    {
        self.owngc().SetSubwindowMode(self.display, mode);
    }
    function DrawString(int x, int y, string str)
    {
        self.getgc().DrawString(self.display, self, x, y, str);
    }
    function DrawImageString(int x, int y, string str)
    {
        self.getgc().DrawImageString(self.display, self, x, y, str);
    }
    function getTextWidth(string text)
    {
        var font = self.font;
        if (font == null)
            return 0;
        return font.getTextWidth(self.display, text);
    }
}

//**************************************************************
//                      Window
//**************************************************************

class Window : Drawable
{
    var xic;
    function Destroy()
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XDestroyWindow")(self.display.xdisplay, self.xdrawable);
        self.xdrawable = None;
    }
    function CreateIC()
    {
        var xic = self.xic;
        if (xic == null) {
            var xim = self.display.getIM();
            if (xim) {
                int xwin = self.xdrawable;
                xic = getfun("XCreateIC")(xim,
                    str_to_cstring("inputStyle"), 0x408,
                    str_to_cstring("clientWindow"), xwin,
                    str_to_cstring("focusWindow"), xwin,
                    null);
                if (! xic)
                    xic = false;
            }
            else
                xic = false;
            self.xic = xic;
        }
    }
    function getIC()
    {
        return self.xic;
    }
    function SelectInput(int eventmask)
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XSelectInput")(self.display.xdisplay, self.xdrawable, eventmask);
        if (eventmask & KeyPressMask)
            self.CreateIC();
    }
    function StoreName(string name)
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XStoreName")(self.display.xdisplay, self.xdrawable,
                str_to_cstring(name));
    }
    function SetWMProtocols(names)
    {
        self.display.SetWMProtocols(self, names);
    }
    function Map()
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XMapWindow")(self.display.xdisplay, self.xdrawable);
    }
    function Unmap()
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XUnmapWindow")(self.display.xdisplay, self.xdrawable);
    }
    function ClearArea(int x, int y, int width, int height, int exposures)
    {
        getfun("XClearArea")(self.display.xdisplay, self.xdrawable,
                x, y, width, height, exposures);
    }
    function SetInputFocus(int revert_to)
    {
        getfun("XSetInputFocus")(self.display.xdisplay, self.xdrawable,
                revert_to, CurrentTime);
    }
    function MoveWindow(int x, int y)
    {
        getfun("XMoveWindow")(self.display.xdisplay, self.xdrawable, x, y);
    }
    function ResizeWindow(int width, int height)
    {
        getfun("XResizeWindow")(self.display.xdisplay, self.xdrawable, width, height);
    }
    function MoveResizeWindow(int x, int y, int width, int height)
    {
        getfun("XMoveResizeWindow")(self.display.xdisplay, self.xdrawable,
                x, y, width, height);
    }
    function RaiseWindow()
    {
        getfun("XRaiseWindow")(self.display.xdisplay, self.xdrawable);
    }
    function SetTransientFor(prop_window)
    {
        getfun("XSetTransientForHint")(self.display.xdisplay,
                self.xdrawable, prop_window.xdrawable);
    }
    function ListProperties()
    {
        var view = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var num_prop = view.alloc();
        var props = getfun("XListProperties")(self.display.xdisplay, self.xdrawable, num_prop);
        int n = view[num_prop, 0];
        view = getatomview(n);
        int result[];
        for (int i = 0; i < n; ++i)
            push(result, int(view[props, i]));
        Free(props);
        return result;
    }
    function LookupString(event)
    {
        return self.display._LookupString(self, event);
    }
}

//**************************************************************
//           Higher level
//**************************************************************

class Controller
{
    var display;
    var regwindow;
    var running;
    function Controller()
    {
        self.Controller(new Display());
    }
    function Controller(display)
    {
        self.display = display;
        var regwindow = {};
        regwindow.set_key_type(Hash_key_type_int);
        self.regwindow = regwindow;
    }
    function Close()
    {
        self.display.Close();
    }
    function setDefaultFont(string fontdesc)
    {
        self.display.setDefaultFont(fontdesc);
    }
    function register(window)
    {
        self.regwindow[window.xdrawable] = window;
    }
    function unregister(window)
    {
        var regwindow = self.regwindow;
        if (exists regwindow[window.xdrawable])
            delete regwindow[window.xdrawable];
    }
    function getWindow(int windowid)
    {
        var regwindow = self.regwindow;
        if (exists regwindow[windowid])
            return regwindow[windowid];
        else
            return null;
    }
    function handleEvent(event)
    {
        using namespace Events;
        int w = event.window();
        var window = self.regwindow[w];
        if (window != null)
            window.handle(event);
    }
    function MainLoop()
    {
        self.running = true;
        var display = self.display;
        var event = new Event();
        do {
            display.NextEvent(event);
            if (! getfun("XFilterEvent")(event.eventdata, None))
                self.handleEvent(event);
        } while (self.running);
    }
    function Quit()
    {
        self.running = false;
    }
}

class EventHandler
{
    var window;
    var selectmask;
    var handlers;
    function EventHandler(window, mask)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.window = window;
        self.selectmask = mask;
        self.handlers = [];
    }
    function i_add [vtable] (newhandler)
    {
        push(self.handlers, newhandler);
        self.window.addmask(self.selectmask);
    }
    function handle(event)
    {
        for (var handler in self.handlers)
            handler(event);
    }
}

class ListenerWindow : Window
{
    var controller;
    var mask;
    var OnConfigure;
    var OnExpose;
    var OnKeyPress;
    var OnButtonPress;
    var OnButtonRelease;
    var OnMotion;
    var OnDestroy;
    var OnFocusIn;
    var OnFocusOut;
    var OnClientMessage;
    function ListenerWindow(controller)
    {
        self.mask = 0;
        self.OnConfigure = new EventHandler(self, StructureNotifyMask);
        self.OnExpose = new EventHandler(self, ExposureMask);
        self.OnKeyPress = new EventHandler(self, KeyPressMask);
        self.OnButtonPress = new EventHandler(self, ButtonPressMask);
        self.OnButtonRelease = new EventHandler(self, ButtonReleaseMask);
        self.OnMotion = new EventHandler(self, PointerMotionMask);
        self.OnDestroy = new EventHandler(self, StructureNotifyMask);
        self.OnFocusIn = new EventHandler(self, FocusChangeMask);
        self.OnFocusOut = new EventHandler(self, FocusChangeMask);
        self.OnClientMessage = new EventHandler(self, 0);
        self.controller = controller;
        controller.register(self);
    }
    function addmask(int newmask)
    {
        int mask = self.mask;
        newmask = newmask | mask;
        if (newmask != mask) {
            self.mask =: newmask;
            self.SelectInput(newmask);
        }
    }
    function handle(event)
    {
        var handler;
        switch (event.type()) {
          case ConfigureNotify:
            handler = self.OnConfigure;
            break;
          case Expose:
            handler = self.OnExpose;
            break;
          case KeyPress:
            handler = self.OnKeyPress;
            break;
          case ButtonPress:
            handler = self.OnButtonPress;
            break;
          case ButtonRelease:
            handler = self.OnButtonRelease;
            break;
          case MotionNotify:
            handler = self.OnMotion;
            break;
          case DestroyNotify:
            handler = self.OnDestroy;
            break;
          case FocusIn:
            handler = self.OnFocusIn;
            break;
          case FocusOut:
            handler = self.OnFocusOut;
            break;
          case ClientMessage:
            handler = self.OnClientMessage;
            break;
        }
        if (handler != null)
            handler.handle(event);
    }
}

class TopLevelWindow : ListenerWindow
{
    var controller;
    function TopLevelWindow(controller, string title,
            int x, int y, int width, int height,
            style[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = controller.display;
        self.display = display;
        int background = display.WhitePixel(0);
        if (style != null) {
            if (exists style["background_color"])
                background = style["background_color"].pixel();
        }
        self.xdrawable = display.CreateSimpleWindow(x, y, width, height,
                0, 0, background);
        self.StoreName(title);
        self.ListenerWindow(controller);
    }
}

class ChildWindow : ListenerWindow
{
    function ChildWindow(parent, int x, int y, int width, int height,
            style[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = parent.controller.display;
        self.display = display;
        int border_width = 0;
        int border_color = 0;
        int background = display.WhitePixel(0);
        if (style != null) {
            if (exists style["background_color"])
                background = style["background_color"].pixel();
        }
        self.xdrawable = display.CreateSimpleChildWindow(parent,
                x, y, width, height, border_width, border_color, background);
        self.ListenerWindow(parent.controller);
    }
}

//**************************************************************

// A barely functional text button to be used in examples and tests

class TextButton : ChildWindow
{
    var text;
    var font;
    var width;
    var height;
    var OnClick;
    function TextButton(parent, int x, int y, int width, int height, string text, font)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (font == null)
            font = parent.display.CreateFont("courier-10");
        if (height == 0)
            height = font.getHeight();
        if (width == 0) {
            width = font.getTextWidth(parent.display, text);
            width += 8;
        }
        self.ChildWindow(parent, x, y, width, height);
        self.width = width;
        self.height = height;
        self.text = text;
        self.font = font;
        self.OnClick = new EventHandler(self, ButtonPressMask | ButtonReleaseMask);
        self.OnExpose += function (event)
        {
            int width = self.width;
            int height = self.height;
            self.DrawRectangle(0, 0, width - 1, height - 1);
            var font = self.font;
            string text = self.text;
            int twidth = self.font.getTextWidth(self.display, text);
            int tx = (width - twidth) / 2;
            self.DrawImageString(tx, font.getAscent(), text);
        };
        self.OnButtonRelease += function (event)
        {
            self.OnClick.handle(event);
        };
    }
}

//**************************************************************

// A barely functional edit box to be used in examples and tests

class EditBox : ChildWindow
{
    var font;
    var width;
    var height;
    var baseline;
    var text;
    var pos;
    var offset;
    var has_focus;
    const int MARGINSUP = 2;
    const int MARGINLEFT = 4;
    function EditBox(parent, int x, int y, int width, int height, font)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.text = '';
        self.pos = 0;
        self.offset = 0;
        if (height == 0)
            height = font.getHeight() + MARGINSUP;
        if (width == 0)
            width = 200;
        self.height = height;
        self.baseline = font.getAscent() + MARGINSUP + 1;
        self.width = width;
        self.has_focus = false;
        self.ChildWindow(parent, x, y, width, height);
        self.SetFont(font);
        self.font = font;
        self.OnConfigure += function (event) { self.onconfigure(event); };
        self.OnDestroy += function (event) { self.ondestroy(event); };
        self.OnExpose += function (event) { self.onexpose(event); };
        self.OnKeyPress += function (event) { self.onkeypress(event); };
        self.OnFocusIn += function (event) { self.onfocusin(event); };
        self.OnFocusOut += function (event) { self.onfocusout(event); };
    }
    function getValue()
    {
        return self.text;
    }
    function setValue(string text)
    {
        int has_focus = self.has_focus;
        if (has_focus)
            self.cursor();
        self.text =: text;
        self.pos =: 0;
        self.offset =: 0;
        self.drawall();
        if (has_focus)
            self.cursor();
    }
    function cursor()
    {
        __DEBUG__ && cry(__FUNCTION__);
        string text = self.text;
        int pos = self.pos;
        int height = self.height;
        var font = self.font;
        int x = font.getTextxOff(self.display, substr(text, 0, pos)) -
            self.offset + MARGINLEFT;
        self.SetFunction(GXinvert);
        self.DrawLine(x, MARGINSUP + 1, x, self.baseline + 1);
        self.SetFunction(GXcopy);
    }
    function drawall()
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.ClearArea(0, 0, 0, 0, 0);
        self.DrawImageString(MARGINLEFT - self.offset, MARGINSUP + self.font.getAscent(), self.text);
        self.DrawRectangle(0, 0, self.width - 1, self.height - 1);
    }
    function onconfigure(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.width =: int(event.width());
        self.height =: int(event.height());
        self.baseline = self.font.getAscent() + MARGINSUP + 1;
    }
    function ondestroy(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.width =: 0;
        self.controller.unregister(self);
    }
    function onexpose(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width != 0)
            self.drawall();
    }
    function onfocusin(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width == 0)
            return;
        if (event.window() == self.xdrawable) {
            self.has_focus =: true;
            self.cursor();
        }
    }
    function onfocusout(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width == 0)
            return;
        if (event.window() == self.xdrawable) {
            self.cursor();
            self.has_focus =: false;
        }
    }
    function onkeypress(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = self.display;
        var font = self.font;
        string text = self.text;
        int l = length(text);
        int pos = self.pos;
        int code = event.keycode();
        int width = self.width;
        string key = display.KeysymToString(display.KeycodeToKeysym(code));
        int offset = self.offset;
        int x;
        switch (key) {
          case "Left":
            if (pos > 0) {
                self.cursor();
                self.pos =: --pos;
                x = self.getTextWidth(substr(text, 0, pos));
                if (x < offset) {
                    offset = x - width / 4;
                    if (offset < 0)
                        offset = 0;
                    self.offset =: offset;
                    self.drawall();
                }
                self.cursor();
            }
            return;
          case "Right":
            if (pos < l) {
                self.cursor();
                self.pos = ++pos;
                x = self.getTextWidth(substr(text, 0, pos));
                if (x - offset >= width) {
                    self.offset =: x - width / 4;
                    self.drawall();
                }
                self.cursor();
            }
            return;
          case "End":
            self.cursor();
            self.pos =: l;
            x = self.getTextWidth(text);
            if (x - offset > width) {
                offset = x -  3 * width / 4;
                if (offset < 0)
                    offset = 0;
                self.offset =: offset;
            }
            self.drawall();
            self.cursor();
            return;
          case "Home":
            if (pos != 0) {
                self.cursor();
                self.pos =: 0;
                if (self.offset > 0) {
                    self.offset =: 0;
                    self.drawall();
                }
                self.cursor();
            }
            return;
          case "Delete":
            if (pos < l) {
                self.cursor();
                text = substr(text, 0, pos) + (pos < l - 1 ? substr(text, pos + 1) : "");
                self.text =: text;
                self.drawall();
                self.cursor();
            }
            return;
          case "BackSpace":
            if (pos > 0) {
                self.cursor();
                text = substr(text, 0, pos - 1) + (pos < l ? substr(text, pos) : "");
                --pos;
                self.text =: text;
                self.pos =: pos;
                x = self.getTextWidth(substr(text, 0, pos));
                if (x < offset) {
                    offset -= width / 4;
                    if (offset < 0)
                        offset = 0;
                    self.offset =: offset;
                }
                self.drawall();
                self.cursor();
            }
            return;
        }
        key = self.LookupString(event);
        if (length(key) < 1)
            return;
        switch (key) {
          case "\n": case "\r": case "\e":
            return;
        }
        self.cursor();
        text = substr(text, 0, pos) + key + substr(text, pos);
        pos += length(key);
        self.pos =: pos;
        self.text =: text;
        x = 0;
        if (pos > 0)
            x = self.font.getTextxOff(self.display, substr(text, 0, pos));

        if (x - offset >= width)
            self.offset =: x - width / 4;

        self.drawall();
        self.cursor();
    }
}

} // namespace Guitor

// End.
