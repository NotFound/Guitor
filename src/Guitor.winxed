#! winxed

// Guitor.winxed

// Xlib module via parrot NCI.

$include "GuitorConstants.winxhead";

$include_const "hash_key_type.pasm";

$load "GuitorNci.pbc";

namespace Guitor
{

$include_const "datatypes.pasm";

//**************************************************************
//                 Internal helper functions
//**************************************************************

namespace Xlib__private
{

extern function str_to_achar;
extern function str_to_achar_utf8;
extern function str_to_cstring;
extern function string_from_nci;
extern function getfun;
extern function getxftfun;
extern function getxpmfun;
extern function geteventpad;
extern function getanyview;
extern function getstructureview;
extern function getexposeview;
extern function getcrossingview;
extern function getfocusview;
extern function getmapview;
extern function getmotionview;
extern function getbuttonview;
extern function getkeyview;
extern function getselectionclearview;
extern function getselectionrequestview;
extern function getselectionview;
extern function getclientview;
extern function getxcolorview;
extern function getxftcolorview;
extern function getxftfontview;
extern function getxfontview;
extern function getatomview;
extern function getglyphinfoview;
extern function getview;

extern function newAtomlist;

function XFree(p)
{
    getfun("XFree")(p);
}

} // namespace Xlib__private

using namespace Xlib__private;
using namespace Events;


//**************************************************************
//                       Display
//**************************************************************

class Display
{
    var xdisplay;
    var default_screen;
    var default_font;
    var xim;

    function Display(string displayname[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var d;
        if (displayname == null)
            displayname = "";
        d = str_to_cstring(displayname);
        self.xdisplay = getfun("XOpenDisplay")(d);
        getfun("setlocale")(0, str_to_cstring(""));
        getfun("XSetLocaleModifiers")(str_to_cstring(""));
        self.default_screen = self._DefaultScreen();
    }
    function Close()
    {
        __DEBUG__ && cry("Display.Close");
        getfun("XCloseDisplay")(self.xdisplay);
        self.xdisplay = null;
        __DEBUG__ && cry("closed");
    }
    function Flush()
    {
        getfun("XFlush")(self.xdisplay);
    }
    function Sync(int discard)
    {
        getfun("XSync")(self.xdisplay, discard);
    }
    function _DefaultScreen()
    {
        int scrnum = getfun("XDefaultScreen")(self.xdisplay);
        return scrnum;
    }
    function DefaultScreen()
    {
        return int(self.default_screen);
    }
    function DefaultDepth(int scrnum)
    {
        int depth = getfun("XDefaultDepth")(self.xdisplay, scrnum);
        return depth;
    }
    function DefaultVisual(int scrnum[optional])
    {
        return getfun("XDefaultVisual")(self.xdisplay, scrnum);
    }
    function DefaultColormap(int scrnum[optional])
    {
        return getfun("XDefaultColormap")(self.xdisplay, scrnum);
    }
    function Height(int scrnum[optional])
    {
        return int(getfun("XDisplayHeight")(self.xdisplay, scrnum));
    }
    function HeightMM(int scrnum[optional])
    {
        return int(getfun("XDisplayHeightMM")(self.xdisplay, scrnum));
    }
    function Width(int scrnum[optional])
    {
        return int(getfun("XDisplayWidth")(self.xdisplay, scrnum));
    }
    function WidthMM(int scrnum[optional])
    {
        return int(getfun("XDisplayWidthMM")(self.xdisplay, scrnum));
    }
    function BlackPixel(int scrnum)
    {
        return getfun("XBlackPixel")(self.xdisplay, scrnum);
    }
    function WhitePixel(int scrnum)
    {
        return getfun("XWhitePixel")(self.xdisplay, scrnum);
    }
    function KeycodeToKeysym(int keycode)
    {
        return getfun("XKeycodeToKeysym")(self.xdisplay, keycode, 0);
    }
    function KeysymToKeycode(int keysym)
    {
        return getfun("XKeysymToKeycode")(self.xdisplay, keysym);
    }
    function StringToKeysym(string keystring)
    {
        return getfun("XStringToKeysym")(str_to_cstring(keystring));
    }
    function KeysymToString(int keysym)
    {
        var fn = getfun("XKeysymToString");
        return string_from_nci(fn(keysym));
    }
    function getIM()
    {
        var xim = self.xim;
        if (self.xim == null) {
            xim = getfun("XOpenIM")(self.xdisplay, null, null, null);
            if (! xim)
                xim = false;
            self.xim = xim;
        }
        return xim;
    }
    function _LookupString(window, event)
    {
        const int BUFSIZE = 32;
        var buffer = new ["ByteBuffer"];
        buffer =: BUFSIZE;
        int len;
        var fun;
        var xic = window.getIC();
        if (xic == null || ! xic) {
            fun = getfun("XLookupString");
            len = fun(event.eventdata, buffer, BUFSIZE, null, null);
        }
        else {
            fun = getfun("XmbLookupString");
            len = fun(xic, event.eventdata, buffer, BUFSIZE, null, null);
        }
        string str;
        if (len > 0) {
            buffer =: len;
            str = buffer.get_string("utf8");
        }
        return str;
    }
    function InternAtom(string name, int only_if_exists[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var pname = str_to_cstring(name);
        int atom = getfun("XInternAtom")(self.xdisplay, pname, only_if_exists);
        return atom;
    }
    function GetAtomName(int atom)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var name = getfun("XGetAtomName")(self.xdisplay, atom);
        string sname = name.as_string("ascii");
        XFree(name);
        return sname;
    }
    function AtomlistFromStrings(var atomnames)
    {
        __DEBUG__ && cry(__FUNCTION__);
        int natoms = elements(atomnames);
        var aux = newAtomlist(natoms);
        var ast = getatomview(elements(atomnames));
        for (int i = 0; i < natoms; ++i)
            ast[aux, i] = int(self.InternAtom(atomnames[i]));
        return aux;
    }
    function DefaultGC()
    {
        var fn = getfun("XDefaultGC");
        return fn(self.xdisplay, self.default_screen);
    }
    function _RootWindow(int scrnum)
    {
        __DEBUG__ && cry(__FUNCTION__);
        return getfun("XRootWindow")(self.xdisplay, scrnum);
    }
    function RootWindow(int scrnum)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XRootWindow");
        var rootw = new Window;
        rootw.display = self;
        rootw.xdrawable = int(fn(self.xdisplay, scrnum));
        return rootw;
    }
    function CreateSimpleWindow(var parent,
        int x, int y, int width, int height,
        int border_width, int border, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, parent.xdrawable,
                x, y, width, height, border_width, border, background);
    }
    function CreateSimpleWindow(int x, int y, int width, int height,
        int border_width, int border, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, self._RootWindow(0),
                x, y, width, height, border_width, border, background);
    }
    function CreateSimpleWindow(int x, int y, int width, int height)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, self._RootWindow(0), x, y, width, height,
                0, self.BlackPixel(0), self.WhitePixel(0));
    }
    function CreateSimpleChildWindow(parent, x, y, width, height,
            int border_width, int border_color, int background)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var fn = getfun("XCreateSimpleWindow");
        return fn(self.xdisplay, parent.xdrawable, x, y, width, height,
                border_width, border_color, background);
    }
    function _DestroyWindow(int xwindow)
    {
        getfun("XDestroyWindow")(self.xdisplay, xwindow);
    }
    function Pending()
    {
        return int(getfun("XPending")(self.xdisplay));
    }
    function NextEvent(var event)
    {
        using namespace Events;
        var fn = getfun("XNextEvent");
        event._get(self.xdisplay, fn);
    }
    function SendEvent(int xwindow, int propagate, int event_mask, event)
    {
        getfun("XSendEvent")(self.xdisplay, xwindow,
                propagate, event_mask, event.eventdata);
    }
    function WarpPointer(int xwindow, int x, int y)
    {
        getfun("XWarpPointer")(self.xdisplay, None, xwindow, 0, 0, 0, 0, x, y);
    }
    function SetWMProtocols(drawable, names)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var atomlist = self.AtomlistFromStrings(names);
        var fn = getfun("XSetWMProtocols");
        fn(self.xdisplay, drawable.xdrawable, atomlist, elements(names));
    }

    function ParseColor(string spec)
    {
        var xdisplay = self.xdisplay;
        var colormap = self.DefaultColormap();
/*
        var xcolorview = getxcolorview();
        var xcolor = xcolorview.alloc();
        int status = getfun("XParseColor")(xdisplay, colormap, str_to_cstring(spec), xcolor);
        if (status) {
            status = getfun("XAllocColor")(xdisplay, colormap, xcolor);
            if (status)
                return new Color(xcolor);
        }
*/
        var xftcolorview = getxftcolorview();
        var xftcolor = xftcolorview.alloc();
        var visual = self.DefaultVisual();
        if (getxftfun("XftColorAllocName")(xdisplay, visual, colormap,
                str_to_cstring(spec), xftcolor)) {
            var color = new XftColor;
            color.xftcolor = xftcolor;
            return color;
        }

        return null;
    }
    function setDefaultFont(string fontdesc)
    {
        var font = self.default_font;
        if (font == null) {
            var ptr = new ["StructView"]( [DATATYPE_STRUCT, 1, DATATYPE_PTR ] );
            var p1 = ptr.alloc();
            var p2 = ptr.alloc();
            var p3 = ptr.alloc();
            var xfont = getfun("XCreateFontSet")(self.xdisplay,
                    str_to_cstring(fontdesc), p1, p2, p3);
            if (xfont == null || ! xfont)
                return false;
            font = new FontSet;
            font.xfont = xfont;
        }
        self.default_font = font;
        return true;
    }
    function getDefaultFont()
    {
        var font = self.default_font;
        if (font == null) {
            self.setDefaultFont("-*-*-*-r-*-*-*-140-*");
            font = self.default_font;
        }
        return font;
    }
    function CreateFont(string name)
    {
        var xdisplay = self.xdisplay;
        var pname = str_to_cstring(name);
        var fun = getxftfun("XftFontOpenXlfd");
        if (fun == null)
            throw "Xft not available";
        var xftfont = fun(xdisplay, 0, pname);
        if (xftfont == null) {
            xftfont = getxftfun("XftFontOpenName")(xdisplay, 0, pname);
            if (xftfont == null)
                return null;
        }
        var font = new XftFont;
        font.xftfont = xftfont;
        return font;
    }
    function _CreatePixmapFromBuffer(int xdrawable, string buffer)
    {
        var fun = getxpmfun("XpmCreatePixmapFromBuffer");
        if (fun == null || ! fun)
            throw "Cannot create pixmap from buffer";
        var intview = new ["StructView"]( [DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var pixmap_return = intview.alloc();
        var shapemask_return;
        var attributes;
        int r = fun(self.xdisplay, xdrawable, str_to_cstring(buffer),
            pixmap_return, shapemask_return, attributes);
        if (r != 0)
            return None;
        return int(intview[pixmap_return, 0]);
    }
    function _CreatePixmapAndShapeFromBuffer(int xdrawable, string buffer)
    {
        var fun = getxpmfun("XpmCreatePixmapFromBuffer");
        if (fun == null || ! fun)
            throw "Cannot create pixmap from buffer";
        var intview = new ["StructView"]( [DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var pixmap_return = intview.alloc();
        var shapemask_return = intview.alloc();;
        var attributes;
        int r = fun(self.xdisplay, xdrawable, str_to_cstring(buffer),
            pixmap_return, shapemask_return, attributes);
        int pixmap = None, shape = None;
        if (r == 0) {
            pixmap = int(intview[pixmap_return, 0]);
            shape = int(intview[shapemask_return, 0]);
        }
        return pixmap, shape;
    }
    function _SetSelectionOwner(int selection, int xwindow, int time)
    {
        getfun("XSetSelectionOwner")(self.xdisplay,
                selection, xwindow, time);
    }
    function SetSelectionOwner(int selection, window, int time)
    {
        int xwindow = window == null ? None : window.xdrawable;
        self._SetSelectionOwner(selection, xwindow, time);
    }
    function GetSelectionOwner(int selection)
    {
        return int(getfun("XGetSelectionOwner")(self.xdisplay, selection));
    }
    function _ConvertSelection(int selection, int target, int property,
            int requestor, int time)
    {
        getfun("XConvertSelection")(self.xdisplay, selection, target,
                    property, requestor, time);
    }
    function ConvertSelection(int selection, int target, int property,
            requestor, int time)
    {
        getfun("XConvertSelection")(self.xdisplay, selection, target,
                    property, requestor.xdrawable, time);
    }
    function ChangePropertyInt32(int xwindow,
            int property, int type, int mode, int value)
    {
        var viewint = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var pvalue = viewint.alloc();
        viewint[pvalue, 0] = value;
        var fun = getfun("XChangeProperty");
        fun(self.xdisplay, xwindow, property, type, 32, mode,
                pvalue, 1);
    }
    function ChangePropertyString(int xwindow,
            int property, int type, int mode, string value)
    {
        var pvalue = str_to_achar_utf8(value);
        var fun = getfun("XChangeProperty");
        fun(self.xdisplay, xwindow, property, type, 8, mode,
                pvalue, elements(pvalue));
    }
    function ChangePropertyStringIso(int xwindow,
            int property, int type, int mode, string value)
    {
        var pvalue = str_to_achar(value);
        var fun = getfun("XChangeProperty");
        fun(self.xdisplay, xwindow, property, type, 8, mode,
                pvalue, elements(pvalue));
    }
}

//**********************************************************************

class Color
{
    var xcolor;
    function Color(xcolor)
    {
        self.xcolor = xcolor;
    }
    function pixel()
    {
        var xcolorview = getxcolorview();
        return int(xcolorview[self.xcolor, 0]);
    }
}

class XftColor
{
    var xftcolor;
    function pixel()
    {
        var xftcolorview = getxftcolorview();
        int pixel = xftcolorview[self.xftcolor, 0];
        return pixel;
    }
}

//**********************************************************************

class FontSet
{
    var xfont;
    function DrawString(display, drawable, int x, int y, string str)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable == None)
            return;
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        getfun("XmbDrawString")(display.xdisplay, xdrawable,
            self.xfont, drawable.getgc().xgc, x, y, pstr, len);
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable == None)
            return;
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        getfun("XmbDrawImageString")(display.xdisplay, xdrawable,
            self.xfont, drawable.getgc().xgc, x, y, pstr, len);
    }
    function getHeight()
    {
        var view = getxfontview();
        return int(view[self.xfont, 22]) + int(view[self.xfont, 23]);
    }
    function getTextWidth(display, string text)
    {
        return int(getfun("XmbTextEscapement")(self.xfont, str_to_cstring(text), bytelength(text)));
    }
    function getTextxOff(display, string text)
    {
        return self.getTextWidth(display, text);
    }
}

class XftFont
{
    var xftfont;
    function DrawString(display, drawable, int x, int y, string str)
    {
        if (length(str) == 0)
            return;
        var xftdraw = drawable._getXftDraw();
        if (xftdraw == null)
            return;
        var gc = drawable.getgc();
        var xcolor;
        var color = gc.getForeground();
        if (color != null)
            xcolor = color.xftcolor;
        if (xcolor == null) {
            color = display.ParseColor("black");
            xcolor = color.xftcolor;
        }

        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);
        getxftfun("XftDrawStringUtf8")(xftdraw, xcolor, self.xftfont,
            x, y, pstr, len);
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        if (length(str) == 0)
            return;
        var xftdraw = drawable._getXftDraw();
        if (xftdraw == null)
            return;
        var pstr = str_to_achar_utf8(str);
        int len = elements(pstr);

        var xftfont = self.xftfont;
        var fview = getxftfontview();
        int ascent = fview[xftfont, 0];
        var tview = getglyphinfoview();
        var glyphinfo = tview.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, xftfont,
                pstr, len, glyphinfo);
        int top  = y - tview[glyphinfo, 3];
        int left = x - tview[glyphinfo, 2];
        int width = tview[glyphinfo, 0];
        int height = tview[glyphinfo, 1];

        var gc = drawable.getgc();
        var xcolor;
        var color = gc.getForeground();
        if (color != null)
            xcolor = color.xftcolor;
        if (xcolor == null) {
            color = display.ParseColor("black");
            xcolor = color.xftcolor;
        }
        var xbgcolor;
        var bgcolor = gc.getBackground();
        if (bgcolor != null)
            xbgcolor = bgcolor.xftcolor;
        if (xbgcolor == null) {
            bgcolor = display.ParseColor("white");
            xbgcolor = bgcolor.xftcolor;
        }

        getxftfun("XftDrawRect")(xftdraw, xbgcolor, left, top, width, height);
        getxftfun("XftDrawStringUtf8")(xftdraw, xcolor, xftfont,
            x, y, pstr, len);
    }
    function getAscent()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 0]);
    }
    function getDescent()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 1]);
    }
    function getHeight()
    {
        var view = getxftfontview();
        return int(view[self.xftfont, 2]);
    }
    function getTextWidth(display, string text)
    {
        var pstr = str_to_achar_utf8(text);
        int len = elements(pstr);
        var view = getglyphinfoview();
        var glyphinfo = view.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, self.xftfont,
                pstr, len, glyphinfo);
        return int(view[glyphinfo, 0]);
    }
    function getTextxOff(display, string text)
    {
        var pstr = str_to_achar_utf8(text);
        int len = elements(pstr);
        var view = getglyphinfoview();
        var glyphinfo = view.alloc();
        getxftfun("XftTextExtentsUtf8")(display.xdisplay, self.xftfont,
                pstr, len, glyphinfo);
        return int(view[glyphinfo, 4]);
    }
}

//**********************************************************************

function DisplayName()
{
    var fn = getfun("XDisplayName");
    return string_from_nci(fn(null));
}

function KeysymToString(int keysym)
{
    var fn = getfun("XKeysymToString");
    return string_from_nci(fn(keysym));
}

function StringToKeysym(string keystring)
{
    var fn = getfun("XStringToKeysym");
    var pkey = str_to_cstring(keystring);
    int k = fn(pkey);
    return k;
}

function OpenDisplay(string displayname[optional])
{
    return new Display(displayname);
}

//**************************************************************
//                        Event
//**************************************************************

class Event
{
    var eventdata;
    var anyview;
    var evtype;
    var evx;
    var evy;
    var evx_root;
    var evy_root;
    var evwidth;
    var evheight;
    var evkeycode;
    var evbutton;
    var evstate;
    var time;
    function Event(int type[optional])
    {
        self.eventdata = geteventpad().alloc();
        self.anyview = getanyview();
        self.evtype = type;
        self.anyview[self.eventdata, 0] = type;
        self.evx = 0;
        self.evy = 0;
        self.evx_root = 0;
        self.evy_root = 0;
        self.evwidth = 0;
        self.evheight = 0;
        self.evkeycode = -1;
        self.evbutton = 0;
        self.evstate = 0;
    }
    function getview()
    {
        var view = self.anyview;
        int type = view[self.eventdata, 0];
        switch (type) {
          case ConfigureNotify:
            view   = getstructureview();
            break;
          case Expose:
            view   = getexposeview();
            break;
          case KeyPress:
            view    = getkeyview();
            break;
          case ButtonPress:
          case ButtonRelease:
            view   = getbuttonview();
            break;
          case MotionNotify:
            view   = getmotionview();
            break;
          case FocusIn:
          case FocusOut:
            view   = getfocusview();
            break;
          case MapNotify:
          case UnmapNotify:
            view   = getmapview();
            break;
          case EnterNotify:
          case LeaveNotify:
            view   = getcrossingview();
            break;
          case SelectionClear:
            view   = getselectionclearview();
            break;
          case SelectionRequest:
            view   = getselectionrequestview();
            break;
          case SelectionNotify:
            view   = getselectionview();
            break;
        }
        return view;
    }
    function _get(xdisplay, fn)
    {
        var eventdata = self.eventdata;
        fn(xdisplay, eventdata);
        var view = self.anyview;
        int type = view[self.eventdata, 0];
        self.evtype =: type;
        int x = 0, y = 0, x_root = 0, y_root = 0,
                width = 0, height = 0,
                keycode = -1, button = 0,
                state = 0, time = 0;
        switch (type) {
          case ConfigureNotify:
            view   = getstructureview();
            x      = view[eventdata, 6];
            y      = view[eventdata, 7];
            width  = view[eventdata, 8];
            height = view[eventdata, 9];
            break;
          case Expose:
            view   = getexposeview();
            x      = view[eventdata, 5];
            y      = view[eventdata, 6];
            width  = view[eventdata, 7];
            height = view[eventdata, 8];
            break;
          case KeyPress:
            view    = getkeyview();
            time    = view[eventdata, 7];
            x       = view[eventdata, 8];
            y       = view[eventdata, 9];
            x_root  = view[eventdata, 10];
            y_root  = view[eventdata, 11];
            keycode = view[eventdata, 13];
            state   = view[eventdata, 12];
            break;
          case ButtonPress:
          case ButtonRelease:
            view   = getbuttonview();
            time   = view[eventdata, 7];
            x      = view[eventdata, 8];
            y      = view[eventdata, 9];
            x_root = view[eventdata, 10];
            y_root = view[eventdata, 11];
            button = view[eventdata, 13];
            state  = view[eventdata, 12];
            break;
          case MotionNotify:
            view   = getmotionview();
            time   = view[eventdata, 7];
            x      = view[eventdata, 8];
            y      = view[eventdata, 9];
            x_root = view[eventdata, 10];
            y_root = view[eventdata, 11];
            state  = view[eventdata, 12];
            break;
          case FocusIn:
          case FocusOut:
            view   = getfocusview();
            break;
          case EnterNotify:
          case LeaveNotify:
            view   = getcrossingview();
            time   = view[eventdata, 7];
            x      = view[eventdata, 8];
            y      = view[eventdata, 9];
            x_root = view[eventdata, 10];
            y_root = view[eventdata, 11];
            state  = view[eventdata, 16];
            break;
          case SelectionClear:
            view   = getselectionclearview();
            time   = view[eventdata, 6];
            break;
          case SelectionRequest:
            view   = getselectionrequestview();
            time   = view[eventdata, 9];
            break;
          case SelectionNotify:
            view   = getselectionview();
            time   = view[eventdata, 8];
            break;
        }
        self.evx =: x;
        self.evy =: y;
        self.evx_root =: x_root;
        self.evy_root =: y_root;
        self.evwidth =: width;
        self.evheight =: height;
        self.evkeycode =: keycode;
        self.evbutton =: button;
        self.evstate =: state;
        self.time = time;
    }
    function type()
    {
        return int(self.evtype);
    }
    function serial()
    {
        int t = self.anyview[self.eventdata, 1];
        return t;
    }
    function window()
    {
        int t = self.anyview[self.eventdata, 4];
        return t;
    }
    function time()
    {
        return int(self.time);
    }
    function x()
    {
        return int(self.evx);
    }
    function y()
    {
        return int(self.evy);
    }
    function x_root()
    {
        return int(self.evx_root);
    }
    function y_root()
    {
        return int(self.evy_root);
    }
    function width()
    {
        return int(self.evwidth);
    }
    function height()
    {
        return int(self.evheight);
    }
    function keycode()
    {
        return int(self.evkeycode);
    }
    function keyname()
    {
        int keycode = self.evkeycode;
        string key;
        if (keycode >= 0) {
            var xdisplay = self.anyview[self.eventdata, 3];
            int keysym = getfun("XKeycodeToKeysym")(xdisplay, keycode, 0);
            key = KeysymToString(keysym);
        }
        return key;
    }
    function button()
    {
        return int(self.evbutton);
    }
    function state()
    {
        return int(self.evstate);
    }
    function detail()
    {
        int detail = 0;
        int type = self.evtype;
        var view;
        switch (type) {
          case EnterNotify:
          case LeaveNotify:
            view = getcrossingview();
            detail = view[self.eventdata, 13];
            break;
          case FocusIn:
          case FocusOut:
            view = getfocusview();
            detail = view[self.eventdata, 6];
            break;
        }
        return detail;
    }
    function requestor()
    {
        int req = None;
        int type = self.evtype;
        var view;
        int pos;
        switch (type) {
          case SelectionRequest:
            view   = getselectionrequestview();
            pos = 5;
            break;
          case SelectionNotify:
            view   = getselectionview();
            pos = 4;
            break;
        }
        if (view != null)
            req = view[self.eventdata, pos];
        return req;
    }
    function selection()
    {
        int req = None;
        int type = self.evtype;
        var view;
        int pos;
        switch (type) {
          case SelectionClear:
            view   = getselectionclearview();
            pos = 5;
            break;
          case SelectionRequest:
            view   = getselectionrequestview();
            pos = 6;
            break;
          case SelectionNotify:
            view   = getselectionview();
            pos = 5;
            break;
        }
        if (view != null)
            req = view[self.eventdata, pos];
        return req;
    }
    function target()
    {
        int req = None;
        int type = self.evtype;
        var view;
        int pos;
        switch (type) {
          case SelectionRequest:
            view   = getselectionrequestview();
            pos = 7;
            break;
          case SelectionNotify:
            view   = getselectionview();
            pos = 6;
            break;
        }
        if (view != null)
            req = view[self.eventdata, pos];
        return req;
    }
    function property()
    {
        int req = None;
        int type = self.evtype;
        var view;
        int pos;
        switch (type) {
          case SelectionRequest:
            view   = getselectionrequestview();
            pos = 8;
            break;
          case SelectionNotify:
            view   = getselectionview();
            pos = 7;
            break;
        }
        if (view != null)
            req = view[self.eventdata, pos];
        return req;
    }
    function message_type()
    {
        int type = 0;
        if (self.evtype == ClientMessage) {
            var view = getclientview();
            type = view[self.eventdata, 5];
        }
        return type;
    }
    function message_data(int n)
    {
        int data = 0;
        if (self.evtype == ClientMessage) {
            var view = getclientview();
            data = view[self.eventdata, 7 + n];
        }
        return data;
    }
}

//**************************************************************
//                      GC
//**************************************************************

class GraphicContext
{
    var display;
    var xgc;
    var color;
    var bgcolor;
    var font;
    function GraphicContext(display)
    {
        self.display = display;
        self.xgc = display.DefaultGC();
    }
    function GraphicContext(display, drawable)
    {
        self.display = display;
        self.xgc = getfun("XCreateGC")
                (display.xdisplay, drawable.xdrawable, null, 0);
    }

    function SetForeground(string spec)
    {
        var color = self.display.ParseColor(spec);
        if (color != null) {
            self.color = color;
            getfun("XSetForeground")(self.display.xdisplay, self.xgc, color.pixel());
        }
    }
    function SetForeground [multi("_", "String")] (spec)
    {
        self.SetForeground(string(spec));
    }
    function SetForeground(var color)
    {
        self.color = color;
        getfun("XSetForeground")(self.display.xdisplay, self.xgc, color.pixel());
    }
    function SetBackground(string spec)
    {
        var color = self.display.ParseColor(spec);
        if (color != null)  {
            self.bgcolor = color;
            getfun("XSetBackground")(self.display.xdisplay, self.xgc, color.pixel());
        }
    }
    function SetBackground [multi("_", "String")] (spec)
    {
        self.SetBackground(string(spec));
    }
    function SetBackground(var color)
    {
        self.bgcolor = color;
        getfun("XSetBackground")(self.display.xdisplay, self.xgc, color.pixel());
    }
    function getForeground()
    {
        return self.color;
    }
    function getBackground()
    {
        return self.bgcolor;
    }
    function SetFunction(display, int func)
    {
        getfun("XSetFunction")(display.xdisplay, self.xgc, func);
    }
    function SetLineAttributes(display, int width,
            int style, int cap, int join)
    {
        getfun("XSetLineAttributes")(display.xdisplay, self.xgc,
                width, style, cap, join);
    }
    function SetSubwindowMode(display, int mode)
    {
        getfun("XSetSubwindowMode")(display.xdisplay, self.xgc, mode);
    }
    function SetClipMask(pixmap)
    {
        int xpixmap = None;
        if (pixmap != null)
            xpixmap = pixmap.xdrawable;
        getfun("XSetClipMask")(self.display.xdisplay, self.xgc, xpixmap);
    }

    function _DrawPoint(display, int xdrawable, int x, int y)
    {
        getfun("XDrawPoint")(display.xdisplay, xdrawable,
                self.xgc, x, y);
    }
    function DrawPoint(display, drawable, int x, int y)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None)
            getfun("XDrawPoint")(display.xdisplay, xdrawable,
                    self.xgc, x, y);
    }
    function _DrawLine(display, int xdrawable, int x1, int y1, int x2, int y2)
    {
        getfun("XDrawLine")(display.xdisplay, xdrawable,
                self.xgc, x1, y1, x2, y2);
    }
    function DrawLine(display, drawable, int x1, int y1, int x2, int y2)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None)
            getfun("XDrawLine")(display.xdisplay, xdrawable,
                    self.xgc, x1, y1, x2, y2);
    }
    function _DrawRectangle(display, int xdrawable,
            int x, int y, int width, int height)
    {
        getfun("XDrawRectangle")(display.xdisplay, xdrawable,
                self.xgc, x, y, width, height);
    }
    function DrawRectangle(display, drawable,
            int x, int y, int width, int height)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None)
            getfun("XDrawRectangle")(display.xdisplay, xdrawable,
                    self.xgc, x, y, width, height);
    }
    function _FillRectangle(display, int xdrawable,
            int x, int y, int width, int height)
    {
        getfun("XFillRectangle")(display.xdisplay, xdrawable,
                self.xgc, x, y, width, height);
    }
    function FillRectangle(display, drawable,
            int x, int y, int width, int height)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None)
            getfun("XFillRectangle")(display.xdisplay, xdrawable,
                    self.xgc, x, y, width, height);
    }
    function DrawLines(display, drawable, x, y)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None) {
            int n = elements(x);
            var xpointview = new ["StructView"] ( [ DATATYPE_STRUCT, 2,
                    DATATYPE_SHORT, DATATYPE_SHORT ] );
            var points = xpointview.alloc(n);
            for (int i = 0; i < n; ++i) {
                int xi = x[i];
                int yi = y[i];
                var point = xpointview.array_offs(points, i);
                xpointview[point, 0] = xi;
                xpointview[point, 1] = yi;
            }
            getfun("XDrawLines")(display.xdisplay, xdrawable,
                    self.xgc, points, n, CoordModePrevious);
        }
    }
    function FillPolygon(display, drawable, x, y)
    {
        int xdrawable = drawable.xdrawable;
        if (xdrawable != None) {
            int n = elements(x);
            var xpointview = new ["StructView"] ( [ DATATYPE_STRUCT, 2,
                    DATATYPE_SHORT, DATATYPE_SHORT ] );
            var points = xpointview.alloc(n);
            for (int i = 0; i < n; ++i) {
                int xi = x[i];
                int yi = y[i];
                var point = xpointview.array_offs(points, i);
                xpointview[point, 0] = xi;
                xpointview[point, 1] = yi;
            }
            getfun("XFillPolygon")(display.xdisplay, xdrawable,
                    self.xgc, points, n, 0, CoordModePrevious);
        }
    }

    function DrawString(display, drawable, int x, int y, string str)
    {
        var font = drawable.font;
        if (font == null)
            font = display.getDefaultFont();
        if (font != null)
            font.DrawString(display, drawable, x, y, str);
        else {
            var xgc = self.xgc;
            var pstr = str_to_achar_utf8(str);
            int len = elements(pstr);
            getfun("XDrawString")(display.xdisplay, drawable.xdrawable,
                    xgc, x, y, pstr, len);
        }
    }
    function DrawImageString(display, drawable, int x, int y, string str)
    {
        var font = drawable.font;
        if (font == null)
            font = display.getDefaultFont();
        if (font != null)
            font.DrawImageString(display, drawable, x, y, str);
        else {
            var xgc = self.xgc;
            var pstr = str_to_achar_utf8(str);
            int len = elements(pstr);
            getfun("XDrawImageString")(display.xdisplay, drawable.xdrawable,
                    xgc, x, y, pstr, len);
        }
    }
}

//**************************************************************
//                      Drawable
//**************************************************************

class Drawable
{
    var display;
    var xdrawable;
    var xftdraw;
    var gc;
    var font;
    function finalizedrawable()
    {
        var xftdraw = self.xftdraw;
        if (xftdraw != null) {
            getxftfun("XftDrawDestroy")(xftdraw);
            self.xftdraw = null;
        }
        self.xdrawable =: None;
    }
    function getDID()
    {
        // Return the X drawable ID, it can be a Window or a Pixmap id.
        // You may need it to direct interface with Xlib functions,
        // or use as an opaque ID.
        // Note that is not an unique ID, the number can be reused
        // by the X Window system if the resource is closed, or if
        // there are several displays in use.
        return int(self.xdrawable);
    }
    function getgc()
    {
        if (self.xdrawable == None)
            return null;
        var gc = self.gc;
        if (gc == null)
            gc = new GraphicContext(self.display);
        return gc;
    }
    function owngc()
    {
        if (self.xdrawable == None)
            return null;
        var gc = self.gc;
        if (gc == null)
            self.gc = gc = new GraphicContext(self.display, self);
        return gc;
    }
    function SetForeground(string spec)
    {
        self.owngc().SetForeground(spec);
    }
    function SetForeground(var color)
    {
        self.owngc().SetForeground(color);
    }
    function SetBackground(string spec)
    {
        self.owngc().SetBackground(spec);
    }
    function SetBackground(var color)
    {
        self.owngc().SetBackground(color);
    }
    function SetFont(font)
    {
        self.font = font;
    }
    function DrawPoint(int x, int y)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.getgc()._DrawPoint(self.display, xdrawable, x, y);
    }
    function DrawLine(int x1, int y1, int x2, int y2)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.getgc()._DrawLine(self.display, xdrawable, x1, y1, x2, y2);
    }
    function DrawRectangle(int x, int y, int width, int height)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.getgc()._DrawRectangle(self.display, xdrawable,
                    x, y, width, height);
    }
    function FillRectangle(int x, int y, int width, int height)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.getgc()._FillRectangle(self.display, xdrawable,
                    x, y, width, height);
    }
    function DrawLines(x, y)
    {
        self.getgc().DrawLines(self.display, self, x, y);
    }
    function FillPolygon(x, y)
    {
        self.getgc().FillPolygon(self.display, self, x, y);
    }
    function SetFunction(int func)
    {
        self.owngc().SetFunction(self.display, func);
    }
    function SetLineAttributes(int width, int style, int cap, int join)
    {
        self.owngc().SetLineAttributes(self.display, width, style, cap, join);
    }
    function SetSubwindowMode(int mode)
    {
        self.owngc().SetSubwindowMode(self.display, mode);
    }
    function DrawString(int x, int y, string str)
    {
        var gc = self.getgc();
        if (gc != null)
            gc.DrawString(self.display, self, x, y, str);
    }
    function DrawImageString(int x, int y, string str)
    {
        var gc = self.getgc();
        if (gc != null)
            gc.DrawImageString(self.display, self, x, y, str);
    }
    function getTextWidth(string text)
    {
        var font = self.font;
        if (font == null)
            return 0;
        return font.getTextWidth(self.display, text);
    }
    function getTextxOff(string text)
    {
        var font = self.font;
        if (font == null)
            return 0;
        return font.getTextxOff(self.display, text);
    }
    function SetClipMask(pixmap)
    {
        self.getgc().SetClipMask(pixmap);
    }
    function CopyArea(src, int src_x, int src_y, int width, int height, int x, int y)
    {
        getfun("XCopyArea")(self.display.xdisplay, src.xdrawable,
                self.xdrawable, self.getgc().xgc,
                src_x, src_y, width, height, x, y);
    }
    function CreatePixmapFromBuffer(string buffer)
    {
        var display = self.display;
        int xpixmap = display._CreatePixmapFromBuffer(self.xdrawable, buffer);
        if (xpixmap != None) {
            var result = new Pixmap;
            result._set(display, xpixmap);
            return result;
        }
        else
            return null;
    }
    function CreatePixmapAndShapeFromBuffer(string buffer)
    {
        var display = self.display;
        :(int xpixmap, int xshape) =
                display._CreatePixmapAndShapeFromBuffer(self.xdrawable, buffer);
        var pixmap;
        var shape;
        if (xpixmap != None) {
            pixmap = new Pixmap;
            pixmap._set(display, xpixmap);
        }
        if (xshape != None) {
            shape = new Pixmap;
            shape._set(display, xshape);
        }
        return pixmap, shape;
    }
    function _getXftDraw()
    {
        int xdrawable = self.xdrawable;
        if (xdrawable == None)
            return null;
        var display = self.display;
        var xftdraw = self.xftdraw;
        if (xftdraw == null) {
            var visual = display.DefaultVisual();
            var colormap = display.DefaultColormap();
            xftdraw = getxftfun("XftDrawCreate")(display.xdisplay,
                    xdrawable, visual, colormap);
            self.xftdraw = xftdraw;
        }
        return xftdraw;
    }
}

//**************************************************************
//                      Pixmap
//**************************************************************

class Pixmap : Drawable
{
    function Pixmap(from, int width, int height, int depth[optional], int has_depth[opt_flag])
    {
        self.display = from.display;
        if (! has_depth)
            depth = display.DefaultDepth(display.DefaultScreen());
        int xpixmap = getfun("XCreatePixmap")
                (from.display, from.xdrawable, width, height, depth);
        self.xdrawable = xpixmap;
    }
    // Internal only - construct from a X Pixmap
    function _set(display, int xpixmap)
    {
        self.display = display;
        self.xdrawable = xpixmap;
    }
    function Free()
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None) {
            self.finalizedrawable();
            getfun("XFreePixmap")(self.display.xdisplay, xdrawable);
        }
    }
}

//**************************************************************
//                      Window
//**************************************************************

class Window : Drawable
{
    var xic;
    function Destroy()
    {
        __DEBUG__ && cry(__FUNCTION__);
        int xdrawable = self.xdrawable;
        if (xdrawable != None) {
            self.finalizedrawable();
            self.display._DestroyWindow(xdrawable);
        }
    }
    function CreateIC()
    {
        var xic = self.xic;
        if (xic == null) {
            var xim = self.display.getIM();
            if (xim) {
                int xwin = self.xdrawable;
                xic = getfun("XCreateIC")(xim,
                    str_to_cstring("inputStyle"), 0x408,
                    str_to_cstring("clientWindow"), xwin,
                    str_to_cstring("focusWindow"), xwin,
                    null);
                if (! xic)
                    xic = false;
            }
            else
                xic = false;
            self.xic = xic;
        }
    }
    function getIC()
    {
        return self.xic;
    }
    function SelectInput(int eventmask)
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XSelectInput")(self.display.xdisplay, self.xdrawable, eventmask);
        if (eventmask & KeyPressMask)
            self.CreateIC();
    }
    function StoreName(string name)
    {
        __DEBUG__ && cry(__FUNCTION__);
        getfun("XStoreName")(self.display.xdisplay, self.xdrawable,
                str_to_cstring(name));
    }
    function SetWMProtocols(names)
    {
        self.display.SetWMProtocols(self, names);
    }
    function Map()
    {
        __DEBUG__ && cry(__FUNCTION__);
        int xdrawable = self.xdrawable;
        if (xdrawable == None)
            throw "Can't Map window, not open";
        getfun("XMapWindow")(self.display.xdisplay, xdrawable);
    }
    function Unmap()
    {
        __DEBUG__ && cry(__FUNCTION__);
        int xdrawable = self.xdrawable;
        // Silently ignore the closed window cases
        if (xdrawable != None)
            getfun("XUnmapWindow")(self.display.xdisplay, xdrawable);
    }
    function ClearArea(int x, int y, int width, int height, int exposures)
    {
        getfun("XClearArea")(self.display.xdisplay, self.xdrawable,
                x, y, width, height, exposures);
    }
    function SetInputFocus(int revert_to)
    {
        getfun("XSetInputFocus")(self.display.xdisplay, self.xdrawable,
                revert_to, CurrentTime);
    }
    function MoveWindow(int x, int y)
    {
        getfun("XMoveWindow")(self.display.xdisplay, self.xdrawable, x, y);
    }
    function ResizeWindow(int width, int height)
    {
        getfun("XResizeWindow")(self.display.xdisplay, self.xdrawable, width, height);
    }
    function MoveResizeWindow(int x, int y, int width, int height)
    {
        getfun("XMoveResizeWindow")(self.display.xdisplay, self.xdrawable,
                x, y, width, height);
    }
    function RaiseWindow()
    {
        getfun("XRaiseWindow")(self.display.xdisplay, self.xdrawable);
    }
    function SetTransientFor(prop_window)
    {
        getfun("XSetTransientForHint")(self.display.xdisplay,
                self.xdrawable, prop_window.xdrawable);
    }
    function ListProperties()
    {
        var view = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var num_prop = view.alloc();
        var props = getfun("XListProperties")(self.display.xdisplay, self.xdrawable, num_prop);
        int n = view[num_prop, 0];
        view = getatomview(n);
        int result[];
        for (int i = 0; i < n; ++i)
            push(result, int(view[props, i]));
        XFree(props);
        return result;
    }
    function LookupString(event)
    {
        return self.display._LookupString(self, event);
    }
    function GrabPointer(int owner_events, int event_mask,
            int pointer_mode, int keyboard_mode, confine_to, cursor,
            int time)
    {
        var fun = getfun("XGrabPointer");
        int r = fun(self.display.xdisplay, self.xdrawable,
                owner_events, event_mask,  pointer_mode, keyboard_mode,
                confine_to, cursor, time);
        return r;
    }
    function UngrabPointer(int time)
    {
        getfun("XUngrabPointer")(self.display.xdisplay, time);
    }
    function GetPropertyString(int property)
    {
        var display = self.display;
        var viewint = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var viewlong = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_LONG ] );
        var viewptr = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_PTR ] );
        var actual_type_return = viewint.alloc();
        var actual_format_return = viewint.alloc();
        var nitems_return = viewlong.alloc();
        var bytes_after_return = viewlong.alloc();
        var prop_return = viewptr.alloc();
        // Get 0 items, to check the size,
        int r = getfun("XGetWindowProperty")(display.xdisplay, self.xdrawable,
            property, 0, 0, false,
            XA_STRING,
            actual_type_return, actual_format_return,
            nitems_return, bytes_after_return, prop_return);
        if (r != Success)
            return string(null);
        var prop = viewptr[prop_return, 0];
        XFree(prop);
        int n = viewint[bytes_after_return, 0];
        if (n == 0)
            return "";
        n = (n + 3 ) / 4;
        // Now get the size obtained
        r = getfun("XGetWindowProperty")(display.xdisplay, self.xdrawable,
            property, 0, n, true,
            XA_STRING,
            actual_type_return, actual_format_return, nitems_return,
            bytes_after_return, prop_return);
        if (r != Success)
            return string(null);
        prop = viewptr[prop_return, 0];
        string result;
        // This may need some change. For a now, assume that utf8 has
        // been tried and failed, so this is a second guess.
        // Fallback to binary if failed.
        try {
            result = prop.as_string("iso-8859-1");
        }
        catch () {
            result = prop.as_string("binary");
        }
        XFree(prop);
        return result;
    }
    function GetPropertyUtf8String(int property)
    {
        var xdisplay = self.display.xdisplay;
        var viewint = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var viewlong = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_LONG ] );
        var viewptr = new ["StructView"] ( [ DATATYPE_STRUCT, 1, DATATYPE_PTR ] );
        var actual_type_return = viewint.alloc();
        var actual_format_return = viewint.alloc();
        var nitems_return = viewlong.alloc();
        var bytes_after_return = viewlong.alloc();
        var prop_return = viewptr.alloc();
        int utf8_string = self.InternAtom("UTF8_STRING");
        // Get 0 items, to check the size,
        int r = getfun("XGetWindowProperty")(xdisplay, self.xdrawable,
            property, 0, 0, false,
            utf8_string,
            actual_type_return, actual_format_return,
            nitems_return, bytes_after_return, prop_return);
        if (r != Success)
            return string(null);
        var prop = viewptr[prop_return, 0];
        XFree(prop);
        int n = viewint[bytes_after_return, 0];
        if (n == 0)
            return "";
        n = (n + 3 ) / 4;
        // Now get the size obtained
        r = getfun("XGetWindowProperty")(xdisplay, self.xdrawable,
            property, 0, n, true,
            utf8_string,
            actual_type_return, actual_format_return, nitems_return,
            bytes_after_return, prop_return);
        if (r != Success)
            return string(null);
        prop = viewptr[prop_return, 0];
        string result = prop.as_string("utf8");
        XFree(prop);
        return result;
    }

    function SetSelectionOwner(int selection, int time)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.display._SetSelectionOwner(selection, xdrawable, time);
    }
    function ConvertSelection(int selection, int target, int property,
            int time)
    {
        int xdrawable = self.xdrawable;
        if (xdrawable != None)
            self.display._ConvertSelection(selection, target, property,
                    xdrawable, time);
    }
    function InternAtom(string name, int only_if_exists[optional])
    {
        return self.display.InternAtom(name, only_if_exists);
    }
    function GetAtomName(int atom)
    {
        return self.display.GetAtomName(atom);
    }
}

//**************************************************************
//           Higher level
//**************************************************************

class Controller
{
    var display;
    var regwindow;
    var running;
    var actionqueue;
    function Controller()
    {
        self.Controller(new Display());
    }
    function Controller(display)
    {
        self.display = display;
        var regwindow = {};
        regwindow.set_key_type(Hash_key_type_int);
        self.regwindow = regwindow;
        self.actionqueue = [];
    }
    function Close()
    {
        self.display.Close();
    }
    function setDefaultFont(string fontdesc)
    {
        self.display.setDefaultFont(fontdesc);
    }
    function register(window)
    {
        self.regwindow[window.xdrawable] = window;
    }
    function unregister(window)
    {
        var regwindow = self.regwindow;
        if (exists regwindow[window.xdrawable])
            delete regwindow[window.xdrawable];
    }
    function getWindow(int windowid)
    {
        var regwindow = self.regwindow;
        if (exists regwindow[windowid])
            return regwindow[windowid];
        else
            return null;
    }
    function handleEvent(event)
    {
        if (! getfun("XFilterEvent")(event.eventdata, None)) {
            int w = event.window();
            var window = self.regwindow[w];
            if (window != null)
                window.handle(event);
        }
    }
    function MainLoop()
    {
        self.running = true;
        var display = self.display;
        var event = new Event();
        var actionqueue = self.actionqueue;
        do {
            if (elements(actionqueue)) {
                display.Sync(false);
                if (display.Pending() > 0) {
                    do {
                        display.NextEvent(event);
                        self.handleEvent(event);
                    } while (display.Pending() > 0);
                }
                else {
                    var action = shift_var(actionqueue);
                    action();
                }
            }
            else {
                display.NextEvent(event);
                self.handleEvent(event);
            }
        } while (self.running);
    }
    function Quit()
    {
        self.running = false;
    }
    function pushaction(action)
    {
        push(self.actionqueue, action);
    }
}

class EventHandler
{
    var window;
    var selectmask;
    var handlers;
    function EventHandler(window, mask)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.window = window;
        self.selectmask = mask;
        self.handlers = [];
    }
    function i_add [vtable] (newhandler)
    {
        push(self.handlers, newhandler);
        self.window.addmask(self.selectmask);
    }
    function handle(event)
    {
        for (var handler in self.handlers)
            handler(event);
    }
}

class ListenerWindow : Window
{
    var controller;
    var mask;
    var OnConfigure;
    var OnExpose;
    var OnKeyPress;
    var OnButtonPress;
    var OnButtonRelease;
    var OnMotion;
    var OnDestroy;
    var OnEnter;
    var OnLeave;
    var OnFocusIn;
    var OnFocusOut;
    var OnMap;
    var OnUnmap;
    var OnSelectionClear;
    var OnSelectionRequest;
    var OnSelectionNotify;
    var OnClientMessage;
    function ListenerWindow(controller)
    {
        self.mask = 0;
        self.OnConfigure = new EventHandler(self, StructureNotifyMask);
        self.OnExpose = new EventHandler(self, ExposureMask);
        self.OnKeyPress = new EventHandler(self, KeyPressMask);
        self.OnButtonPress = new EventHandler(self, ButtonPressMask);
        self.OnButtonRelease = new EventHandler(self, ButtonReleaseMask);
        self.OnMotion = new EventHandler(self, PointerMotionMask);
        self.OnDestroy = new EventHandler(self, StructureNotifyMask);
        self.OnEnter = new EventHandler(self, EnterWindowMask);
        self.OnLeave = new EventHandler(self, LeaveWindowMask);
        self.OnFocusIn = new EventHandler(self, FocusChangeMask);
        self.OnFocusOut = new EventHandler(self, FocusChangeMask);
        self.OnMap = new EventHandler(self, StructureNotifyMask);
        self.OnUnmap = new EventHandler(self, StructureNotifyMask);
        self.OnSelectionClear = new EventHandler(self, 0);
        self.OnSelectionRequest = new EventHandler(self, 0);
        self.OnSelectionNotify = new EventHandler(self, 0);
        self.OnClientMessage = new EventHandler(self, 0);
        self.controller = controller;
        controller.register(self);
    }
    function addmask(int newmask)
    {
        int mask = self.mask;
        newmask = newmask | mask;
        if (newmask != mask) {
            self.mask =: newmask;
            self.SelectInput(newmask);
        }
    }
    function handle(event)
    {
        var handler;
        switch (event.type()) {
          case ConfigureNotify:
            handler = self.OnConfigure;
            break;
          case Expose:
            handler = self.OnExpose;
            break;
          case KeyPress:
            handler = self.OnKeyPress;
            break;
          case ButtonPress:
            handler = self.OnButtonPress;
            break;
          case ButtonRelease:
            handler = self.OnButtonRelease;
            break;
          case MotionNotify:
            handler = self.OnMotion;
            break;
          case DestroyNotify:
            handler = self.OnDestroy;
            break;
          case FocusIn:
            handler = self.OnFocusIn;
            break;
          case FocusOut:
            handler = self.OnFocusOut;
            break;
          case MapNotify:
            handler = self.OnMap;
            break;
          case UnmapNotify:
            handler = self.OnUnmap;
            break;
          case EnterNotify:
            handler = self.OnEnter;
            break;
          case LeaveNotify:
            handler = self.OnLeave;
            break;
          case SelectionClear:
            handler = self.OnSelectionClear;
            break;
          case SelectionRequest:
            handler = self.OnSelectionRequest;
            break;
          case SelectionNotify:
            handler = self.OnSelectionNotify;
            break;
          case ClientMessage:
            handler = self.OnClientMessage;
            break;
        }
        if (handler != null)
            handler.handle(event);
    }
}

class TopLevelWindow : ListenerWindow
{
    var controller;
    function TopLevelWindow(controller, string title,
            int x, int y, int width, int height,
            style[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = controller.display;
        self.display = display;
        int background = display.WhitePixel(0);
        if (style != null) {
            if (exists style["background-color"])
                background = style["background-color"].pixel();
        }
        self.xdrawable = display.CreateSimpleWindow(x, y, width, height,
                0, 0, background);
        self.StoreName(title);
        self.ListenerWindow(controller);
    }
}

class ChildWindow : ListenerWindow
{
    function ChildWindow(parent, int x, int y, int width, int height,
            style[optional])
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = parent.controller.display;
        self.display = display;
        int border_width = 0;
        int border_color = 0;
        int background = display.WhitePixel(0);
        if (style != null) {
            if (exists style["background-color"])
                background = style["background-color"].pixel();
        }
        self.xdrawable = display.CreateSimpleChildWindow(parent,
                x, y, width, height, border_width, border_color, background);
        self.ListenerWindow(parent.controller);
    }
}

//**************************************************************

// A barely functional text button to be used in examples and tests

class TextButton : ChildWindow
{
    var text;
    var font;
    var width;
    var ascent;
    var height;
    var OnClick;
    function TextButton(parent, int x, int y, int width, int height, string text, font)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (font == null)
            font = parent.display.CreateFont("courier-10");
        int ascent = font.getAscent();
        int descent = font.getDescent();
        if (height == 0)
            height = ascent + descent + 4;
        if (width == 0) {
            width = font.getTextxOff(parent.display, text);
            width += 8;
        }
        self.ChildWindow(parent, x, y, width, height);
        self.width = width;
        self.ascent = ascent;
        self.height = height;
        self.text = text;
        self.font = font;
        self.OnClick = new EventHandler(self, ButtonPressMask | ButtonReleaseMask);
        self.OnExpose += function (event)
        {
            int width = self.width;
            int height = self.height;
            self.DrawRectangle(0, 0, width - 1, height - 1);
            string text = self.text;
            int twidth = self.getTextWidth(text);
            self.DrawImageString((width - twidth) / 2, self.ascent + 2, text);
        };
        self.OnButtonRelease += function (event)
        {
            self.OnClick.handle(event);
        };
    }
    function getwidth() { return int(self.width); }
    function getheight() { return int(self.height); }
}

//**************************************************************

// A barely functional edit box to be used in examples and tests

class EditBox : ChildWindow
{
    var font;
    var width;
    var height;
    var baseline;
    var text;
    var pos;
    var offset;
    var has_focus;
    var sel_from;
    var sel_to;
    var pressed;
    var inipos;
    const int MARGINSUP = 2;
    const int MARGINLEFT = 4;
    function EditBox(parent, int x, int y, int width, int height, font)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.text = '';
        self.pressed = 0;
        self.inipos = 0;
        self.pos = 0;
        self.offset = 0;
        int ascent = font.getAscent();
        if (height == 0)
            height = ascent + font.getDescent() + MARGINSUP + 2;
        if (width == 0)
            width = 200;
        self.height = height;
        self.baseline = ascent + MARGINSUP + 1;
        self.width = width;
        self.has_focus = false;
        self.ChildWindow(parent, x, y, width, height);
        self.SetFont(font);
        self.font = font;
        self.OnConfigure += function (event) { self.onconfigure(event); };
        self.OnDestroy += function (event) { self.ondestroy(event); };
        self.OnExpose += function (event) { self.onexpose(event); };
        self.OnButtonPress += function (event) { self.onbuttonpress(event); };
        self.OnButtonRelease += function (event) { self.onbuttonrelease(event); };
        self.OnMotion += function (event) { self.onmotion(event); };
        self.OnKeyPress += function (event) { self.onkeypress(event); };
        self.OnFocusIn += function (event) { self.onfocusin(event); };
        self.OnFocusOut += function (event) { self.onfocusout(event); };
        self.OnSelectionNotify += function (event) { self.onselectionnotify(event); };
        self.OnSelectionRequest += function (event) { self.onselectionrequest(event); };
        self.OnSelectionClear += function (event) { self.onselectionclear(event); };
    }
    function getwidth() { return int(self.width); }
    function getheight() { return int(self.height); }
    function getValue()
    {
        return self.text;
    }
    function setValue(string text)
    {
        int has_focus = self.has_focus;
        if (has_focus)
            self.cursor();
        self.text =: text;
        self.pos =: 0;
        self.offset =: 0;
        self.drawall();
        if (has_focus)
            self.cursor();
    }
    function getpos(int x)
    {
        x += self.offset - MARGINLEFT;
        if (x < 0)
            return 0;
        string text = self.text;
        int rp = length(text);
        if (rp == 0)
            return 0;
        if (x > self.getTextxOff(text))
            return rp;
        int lp = 0;
        int mp;
        while ((mp = (lp + rp) / 2) != lp) {
            if (x < self.getTextxOff(substr(text, 0, mp)))
                rp = mp;
            else
                lp = mp;
        }
        return x < ((self.getTextxOff(substr(text, 0, mp)) + self.getTextxOff(substr(text, 0, mp + 1))) / 2) ? mp : mp + 1;
    }
    function cursor()
    {
        __DEBUG__ && cry(__FUNCTION__);
        string text = self.text;
        int pos = self.pos;
        int height = self.height;
        int x = self.getTextxOff(substr(text, 0, pos)) -
            self.offset + MARGINLEFT;
        self.SetFunction(GXinvert);
        self.DrawLine(x, MARGINSUP + 1, x, self.baseline + 1);
        self.SetFunction(GXcopy);
    }
    function checkoffset()
    {
        int pos = self.pos;
        int offset = self.offset;
        int old = offset;
        int width = self.width;
        int x = self.getTextxOff(substr(self.text, 0, pos)) + MARGINLEFT;
        if (x < offset) {
            offset = x - width / 3;
            if (offset < 0)
                offset = 0;
        }
        else if (x - offset > width - 2)
            offset = x - 2 * width / 3;
        if (old == offset)
            return 0;
        else {
            self.offset =: offset;
            return offset - old;
        }
    }
    function drawall()
    {
        __DEBUG__ && cry(__FUNCTION__);
        var text = self.text;
        var font = self.font;
        int offset = self.offset;
        self.ClearArea(0, 0, 0, 0, 0);
        self.DrawImageString(MARGINLEFT - offset, MARGINSUP + font.getAscent(), text);
        self.DrawRectangle(0, 0, self.width - 1, self.height - 1);
        var sel_from = self.sel_from;
        if (sel_from != null) {
            int from = sel_from;
            int to = self.sel_to;
            int x1 = self.getTextxOff(substr(text, 0, from));
            int x2 = self.getTextxOff(substr(text, 0, to));
            if (x1 > x2) {
                int aux = x1;
                x1 = x2;
                x2 = aux;
            }
            self.SetFunction(GXinvert);
            self.FillRectangle(MARGINLEFT + x1 - offset, 0, x2 - x1, self.height - 1);
            self.SetFunction(GXcopy);
        }
    }
    function onconfigure(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.width =: int(event.width());
        self.height =: int(event.height());
        self.baseline = self.font.getAscent() + MARGINSUP + 1;
    }
    function ondestroy(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        self.width =: 0;
        self.controller.unregister(self);
    }
    function onexpose(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width != 0)
            self.drawall();
    }
    function onfocusin(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width == 0)
            return;
        if (event.window() == self.getDID()) {
            self.has_focus =: true;
            self.cursor();
        }
    }
    function onfocusout(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        if (self.width == 0)
            return;
        if (event.window() == self.getDID()) {
            self.cursor();
            self.has_focus =: false;
        }
    }
    function onbuttonpress(event)
    {
        self.cursor();
        self.cancelselection();
        int pos = self.getpos(event.x());
        self.pos =: pos;
        self.drawall();
        self.cursor();
        switch (event.button()) {
          case 1:
            self.pressed =: true;
            self.inipos =: pos;
            break;
          case 2:
            // Paste primary selection
            var display = self.display;
            display.ConvertSelection(XA_PRIMARY,
                    self.InternAtom("UTF8_STRING"),
                    XA_PRIMARY, self, event.time());
            break;
        }
    }
    function onbuttonrelease(event)
    {
        if (! self.pressed)
            return;
        self.pressed =: false;
        self.cursor();
        int pos = self.pos;
        int newpos = self.getpos(event.x());
        if (newpos != pos) {
            self.pos =: newpos;
            self.setselection(self.inipos, newpos, event);
        }
        self.drawall();
        self.cursor();
    }
    function onmotion(event)
    {
        if (! self.pressed)
            return;
        self.cursor();
        int pos = self.pos;
        int newpos = self.getpos(event.x());
        if (newpos != pos) {
            self.pos =: newpos;
            int desp = self.checkoffset();
            if (desp)
                self.display.WarpPointer(self.getDID(), event.x() - desp, event.y());
            self.setselection(self.inipos, newpos, event);
        }
        self.drawall();
        self.cursor();
    }
    function onkeypress(event)
    {
        __DEBUG__ && cry(__FUNCTION__);
        var display = self.display;
        string text = self.text;
        int l = length(text);
        int pos = self.pos;
        int code = event.keycode();
        int state = event.state();
        int width = self.width;
        string key = display.KeysymToString(display.KeycodeToKeysym(code));
        int offset = self.offset;
        int x;
        int dall = false;
        int ignore = false;
        self.cursor();
        switch (key) {
          case "Left":
            if (pos > 0) {
                if (state & ShiftMask) {
                    self.changeselection(pos, pos - 1, event);
                    dall = true;
                }
                self.pos =: --pos;
                if (self.checkoffset())
                    dall = true;
            }
            break;
          case "Right":
            if (pos < l) {
                if (state & ShiftMask) {
                    self.changeselection(pos, pos + 1, event);
                    dall = true;
                }
                self.pos = ++pos;
                if (self.checkoffset())
                    dall = true;
            }
            break;
          case "End":
            self.cursor();
            if (state & ShiftMask) {
                self.changeselection(pos, l, event);
                dall = true;
            }
            self.pos =: l;
            if (self.checkoffset())
                dall = true;
            break;
          case "Home":
            if (pos != 0) {
                if (state & ShiftMask) {
                    self.changeselection(pos, 0, event);
                    dall = true;
                }
                self.pos =: 0;
                if (self.offset > 0) {
                    self.offset =: 0;
                    dall = true;
                }
            }
            break;
          case "Delete":
            if (self.sel_from != null) {
                self.deleteselection();
                self.checkoffset();
                dall = true;
                break;
            }
            if (pos < l) {
                self.cursor();
                text = substr(text, 0, pos) + (pos < l - 1 ? substr(text, pos + 1) : "");
                self.text =: text;
                dall = true;
            }
            break;
          case "BackSpace":
            if (self.sel_from != null) {
                self.deleteselection();
                self.checkoffset();
                dall = true;
                break;
            }
            if (pos > 0) {
                self.cursor();
                text = substr(text, 0, pos - 1) + (pos < l ? substr(text, pos) : "");
                --pos;
                self.text =: text;
                self.pos =: pos;
                x = self.getTextWidth(substr(text, 0, pos));
                if (x < offset) {
                    offset -= width / 4;
                    if (offset < 0)
                        offset = 0;
                    self.offset =: offset;
                }
                dall = true;
            }
            break;
          default:
            key = self.LookupString(event);
            switch (key) {
              case "\n": case "\r": case "\e":
                key = "";
                break;
              case "\x{3}":  // Ctrl-C Copy
                self.SetSelectionOwner(self.InternAtom("CLIPBOARD"),
                       event.time());
                key = "";
                break;
              case "\x{16}": // Ctrl-V Paste
                self.paste(event.time());
                key = "";
                break;
            }
            if (length(key) < 1) {
                ignore = true;
                break;
            }
            if (self.sel_from != null) {
                self.deleteselection();
                self.checkoffset();
                dall = true;
                text = self.text;
                pos = self.pos;
            }
            text = substr(text, 0, pos) + key + substr(text, pos);
            pos += length(key);
            self.pos =: pos;
            self.text =: text;
            self.checkoffset();
            dall = true;
        }
        if (! ignore) {
            if (!(state & ShiftMask))
                if (self.cancelselection())
                    dall = true;
        }
        if (dall)
            self.drawall();
        self.cursor();
    }
    function onselectionclear(event)
    {
        int selection = event.selection();
        if (selection != XA_PRIMARY)
            return;

        var sel_from = self.sel_from;
        if (sel_from == null)
            return false;
        self.sel_from = null;
        self.sel_to = null;
        self.drawall();
    }
    function onselectionrequest(event)
    {
        int requestor = event.requestor();
        int selection = event.selection();
        int target = event.target();
        int property = event.property();
        var display = self.display;

        string targetname = self.GetAtomName(target);
        int typeutf8 = self.InternAtom("UTF8_STRING");
        // Request for supported types: answer only utf8 text.
        if (targetname == "TARGETS") {
            display.ChangePropertyInt32(requestor,
                    property, target, PropModeReplace, typeutf8);
        }
        else if (target == typeutf8 || target == XA_STRING) {
            // Request for text: fine, do it.
            string text = self.text;
            string textsel;
            var sel_from = self.sel_from;
            if (sel_from == null)
                textsel = text;
            else {
                int from = sel_from;
                int to = self.sel_to;
                if (from > to) {
                    from = to;
                    to = sel_from;
                }
                textsel = substr(text, from, to - from);
            }
            // Some clients can request STRING without checking.
            // Try to transcode in that case.
            if (target == XA_STRING) {
                try {
                    textsel = trans_encoding(textsel, "iso-8859-1");
                    display.ChangePropertyStringIso(requestor,
                            property, target, PropModeReplace, textsel);
                }
                catch () { }
            }
            else
                display.ChangePropertyString(requestor,
                        property, target, PropModeReplace, textsel);
        }
        else
            return;

        var notify = new Event(SelectionNotify);
        // No much support for creating events yet, use the
        // raw StructView for a now.
        var data = notify.eventdata;
        var view = notify.getview();
        view[data, 4] = requestor;
        view[data, 5] = selection;
        view[data, 6] = target;
        view[data, 7] = property;
        view[data, 8] = event.time();
        display.SendEvent(requestor, false, 0, notify);
    }
    function onselectionnotify(event)
    {
        var display = self.display;
        int selection = event.selection();
        int target = event.target();
        int property = event.property();
        if (property == None) {
            if (target == self.InternAtom("UTF8_STRING")) {
                // Retry with plain string type
                display.ConvertSelection(selection, XA_STRING,
                        selection, self, event.time());
            }
            return;
        }
        string pasted;
        if (target == XA_STRING)
            pasted = self.GetPropertyString(property);
        else
            pasted = self.GetPropertyUtf8String(property);
        if (pasted == null)
            return;
        int l = length(pasted);
        self.cursor();
        int pos = self.pos;
        string text = self.text;
        text = substr(text, 0, pos) + pasted + substr(text, pos);
        pos += l;
        self.text =: text;
        self.pos =: pos;
        self.checkoffset();
        self.drawall();
        self.cursor();
    }
    function paste(int time)
    {
        int clipboard = self.InternAtom("CLIPBOARD");
        // First try to get a utf8 string. onselectonnotify will
        // do some fallback.
        display.ConvertSelection(clipboard, self.InternAtom("UTF8_STRING"),
                clipboard, self, time);
    }
    function cancelselection()
    {
        var sel_from = self.sel_from;
        if (sel_from == null)
            return false;
        self.sel_from = null;
        self.sel_to = null;
        var display = self.display;
        display.SetSelectionOwner(XA_PRIMARY , null, CurrentTime);
        return true;
    }
    function deleteselection()
    {
        int from = self.sel_from;
        int to = self.sel_to;
        if (from > to) {
            to = from;
            from = self.sel_to;
        }
        self.cancelselection();
        string text = self.text;
        text = substr(text, 0, from) + substr(text, to);
        self.text =: text;
        self.pos =: from;
    }
    function setselection(int from, int to, event)
    {
        var sel_from = self.sel_from;
        if (sel_from == null) {
            int time = event == null ? CurrentTime : event.time();
            self.SetSelectionOwner(XA_PRIMARY , time);
        }
        int s_from = from;
        int s_to = to;
         if (from > to) {
            s_from = to;
            s_to = from;
        }
        self.sel_from = s_from;
        self.sel_to = s_to;
    }
    function changeselection(int from, int to, event)
    {
        var sel_from = self.sel_from;
        if (sel_from == null)
            self.setselection(from, to, event);
        else {
            int s_from = sel_from;
            int s_to = self.sel_to;
            if (s_from == from)
                s_from = to;
            else if (s_to == from)
                s_to = to;
            else {
                s_from = from;
                s_to = to;
            }
            self.sel_from = s_from;
            self.sel_to = s_to;
        }
    }
}

//**************************************************************

const int CURRENT_NONE = -1;

// A barely functional context menu to be used in examples and tests.
// No keyboard interface, only mouse.

class MenuItem
{
    var name;
    var action;
    function MenuItem(string name, action)
    {
        self.name = name;
        self.action = action;
    }
}

class MenuWindow : ChildWindow
{
    var menu;
    var x;
    var y;
    var width;
    var height;
    var hbase;
    var xpos;
    var hitem;
    var fgcolor;
    var bgcolor;
    var enter;
    var inside;
    var current;
    function MenuWindow(parent, int x, int y, menu)
    {
        var display = parent.display;
        self.menu = menu;
        self.x = x;
        self.y = y;
        var items = menu.items;
        int nitems = elements(items);
        var font = menu.font;
        int ascent = font.getAscent();
        int hitem = ascent + font.getDescent();
        int hbase = ascent + 1;
        int height = hitem * nitems + 2;
        int width = 0;
        for (var item in menu.items) {
            int iwidth = font.getTextWidth(display, item.name);
            if (iwidth > width)
                width = iwidth;
        }
        int mwidth = font.getTextWidth(display, "M");
        self.xpos = (mwidth + 1) / 2;
        width = width + mwidth * 2;
        self.height = height;
        self.width = width;
        self.hitem = hitem;
        self.hbase = hbase;
        self.enter = false;
        self.inside = false;
        var bgcolor = display.ParseColor("grey");
        var fgcolor = display.ParseColor("black");
        self.fgcolor = fgcolor;
        self.bgcolor = bgcolor;
        self.current = CURRENT_NONE;
        self.ChildWindow(parent, x + 1, y + 1, width, height,
                { "background-color" : bgcolor } );
        self.SetFont(font);
        self.SetForeground(fgcolor);
        self.SetBackground(bgcolor);
        self.OnExpose += function (event) { self.onexpose(event); };
        self.OnEnter += function (event) { self.onenter(event); };
        self.OnLeave += function (event) { self.onleave(event); };
        self.OnButtonPress += function (event) { self.onbuttonpress(event); };
        self.OnButtonRelease += function (event) { self.onbuttonrelease(event); };
        self.OnMotion += function (event) { self.onmotion(event); };
    }
    function drawitem(int nitem, fgcolor, bgcolor)
    {
        var items = self.menu.items;
        int hitem = self.hitem;
        int hbase = self.hbase;
        int width = self.width;
        self.SetForeground(bgcolor);
        self.FillRectangle(1, 1 + nitem * hitem, width - 2, hitem);
        self.SetForeground(fgcolor);
        self.SetBackground(bgcolor);
        self.DrawString(self.xpos, hbase + nitem * hitem, items[nitem].name);
    }
    function changecurrent(int newcurrent)
    {
        int current = self.current;
        if (current == newcurrent)
            return;
        var items = self.menu.items;
        int hitem = self.hitem;
        int hbase = self.hbase;
        int width = self.width;
        var fgcolor = self.fgcolor;
        var bgcolor = self.bgcolor;
        if (current != CURRENT_NONE)
            self.drawitem(current, fgcolor, bgcolor);
        if (newcurrent != CURRENT_NONE)
            self.drawitem(newcurrent, bgcolor, fgcolor);
        self.current =: newcurrent;
    }
    function setcurrent(int x, int y)
    {
        var items = self.menu.items;
        int nitem = (y - 1)/ self.hitem;
        if (x < 0 || x > self.width || nitem < 0 || nitem >= elements(items))
            nitem = CURRENT_NONE;
        self.changecurrent(nitem);
    }
    function onexpose(event)
    {
        var items = self.menu.items;
        int current = self.current;
        var fgcolor = self.fgcolor;
        var bgcolor = self.bgcolor;
        self.DrawRectangle(0, 0, self.width - 1, self.height - 1);
        for (int i = 0, n = elements(items); i < n; ++i)
            if (i == current)
                self.drawitem(i, bgcolor, fgcolor);
            else
                self.drawitem(i, fgcolor, bgcolor);
    }
    function onenter(event)
    {
        self.enter =: true;
        self.inside =: true;
        self.setcurrent(event.x(), event.y());
    }
    function onleave(event)
    {
        self.inside =: false;
    }
    function onbuttonpress(event)
    {
        if (! self.inside) {
            self.UngrabPointer(event.time());
            self.Destroy();
        }
    }
    function onmotion(event)
    {
        self.setcurrent(event.x(), event.y());
    }
    function onbuttonrelease(event)
    {
        self.setcurrent(event.x(), event.y());
        int current = self.current;
        if (current == CURRENT_NONE) {
            if (self.enter) {
                self.UngrabPointer(event.time());
                self.Destroy();
            }
        }
        else {
            self.UngrabPointer(event.time());
            self.Destroy();
            var action = self.menu.items[current].action;
            action();
        }
    }
}

class Menu
{
    var display;
    var font;
    var items;
    function Menu(display, font)
    {
        self.display = display;
        self.font = font;
        self.items = [];
    }
    function push(string name, action)
    {
        push(self.items, new MenuItem(name, action));
    }
    function open(parent, x, y)
    {
        var menuwindow = new MenuWindow(parent, x, y, self);
        menuwindow.Map();
        return menuwindow;
    }
    function _activate(parent, int x, int y, int time)
    {
        var menuwindow = self.open(parent, x, y);
        const int mask = EnterWindowMask | LeaveWindowMask |
                ButtonPressMask | ButtonReleaseMask | PointerMotionMask;
        int grab = menuwindow.GrabPointer(false, mask,
                GrabModeAsync, GrabModeAsync, None, None, time);
        if (grab != 0) {
            // grab failed, cancel
            menuWindow.Destroy();
        }
    }
    function activate(parent, int x, int y, int time[optional],
            int has_time[opt_flag])
    {
        if (! has_time)
            time = CurrentTime;
        self._activate(parent, x, y, time);
    }
    function activate_from(parent, event)
    {
        self._activate(parent, event.x(), event.y(), event.time());
    }
}

//**************************************************************

// A barely functional menu bar to be used in examples and tests.
// No keyboard interface, only mouse.
// TODO: better integration with Menu and MenuWindow.

const int BARSEP = 16;

class MenuBarWindow : ChildWindow
{
    var parent;
    var fgcolor;
    var bgcolor;
    var hibgcolor;
    var menubar;
    var itempos;
    var height;
    var active;
    var curitem;
    var child;
    var grab;
    function MenuBarWindow(parent, int x, int y, int width, menubar)
    {
        self.parent = parent;
        self.menubar = menubar;
        var display = menubar.display;
        var font = menubar.font;
        var fgcolor = display.ParseColor("black");
        var bgcolor = display.ParseColor("grey90");
        self.fgcolor = fgcolor;
        self.bgcolor = bgcolor;
        self.hibgcolor = display.ParseColor("grey70");
        int height = font.getHeight() + 8;
        self.height = height;
        if (width <= 0)
            width = menubar.maxWidth();
        self.active = false;
        self.curitem = CURRENT_NONE;
        self.grab = false;
        self.ChildWindow(parent, x, y, width, height,
                { "background-color" : bgcolor } );
        self.SetFont(font);
        self.SetForeground(fgcolor);
        self.SetBackground(bgcolor);
        var items = self.menubar.items;
        int nitems = elements(items);
        int itempos[nitems];
        int xp = BARSEP / 2;
        for (int i = 0; i < nitems; ++i) {
            itempos[i] = xp;
            xp += self.getTextWidth(items[i].name) + BARSEP;
        }
        self.itempos = itempos;
        self.OnExpose += function (event) { self.onexpose(event); };
        self.OnButtonPress += function (event) { self.onbuttonpress(event); };
        self.OnButtonRelease += function (event) { self.onbuttonrelease(event); };
        self.OnMotion += function (event) { self.onmotion(event); };
    }
    function itemAt(int x)
    {
        var items = self.menubar.items;
        int n = elements(items);
        int xpos = BARSEP / 2;
        int pad = BARSEP / 4;
        for (int i = 0; i < n; ++i) {
            string str = items[i].name;
            int w = self.getTextWidth(str);
            if (x >= xpos - pad && x <= xpos + w + pad)
                return i;
            xpos += w + BARSEP;
        }
        return CURRENT_NONE;
    }
    function querypointer()
    {
        var viewint = new ["StructView"]
                ( [ DATATYPE_STRUCT, 1, DATATYPE_INT ] );
        var child_return = viewint.alloc();
        var win_x_return = viewint.alloc();
        var win_y_return = viewint.alloc();
        var n = viewint.alloc();
        int r = getfun("XQueryPointer")(self.display.xdisplay,
            self.parent.getDID(), n, child_return,
            n, n, win_x_return, win_y_return, n);
        return r,
            int(viewint[child_return, 0]),
            int(viewint[win_x_return, 0]),
            int(viewint[win_y_return, 0]);
    }
    function setcurrent(int nitem)
    {
        __ASSERT__(nitem >= 0);
        __ASSERT__(nitem < elements(self.itempos));
        if (self.child != null)
            self.child.Destroy();
        if (self.curitem != CURRENT_NONE)
            self.updateitem(self.curitem, false);
        self.SetBackground(self.hibgcolor);
        self.updateitem(nitem, true);
        self.SetBackground(self.bgcolor);
        self.curitem = nitem;
        int x = self.itempos[nitem];
        var action = self.menubar.items[nitem].action;
        self.child = action.open(self.parent, x, self.height - 2);
    }
    function deactivate(int time)
    {
        var child = self.child;
        if (child != null) {
            self.child = null;
            self.controller.pushaction(function () { child.Destroy(); } );
        }
        if (self.grab) {
            self.UngrabPointer(time);
            self.grab =: false;
        }
        self.active =: false;
        self.curitem =: CURRENT_NONE;
    }
    function grabme(int time)
    {
        const int mask = EnterWindowMask | LeaveWindowMask |
                ButtonPressMask | ButtonReleaseMask | PointerMotionMask;
        int grab = self.GrabPointer(false, mask,
                GrabModeAsync, GrabModeAsync, None, None, time);
        if (grab == 0) {
            self.grab =: true;
            self.active =: true;
        }
        return grab;
    }
    function updateitem(int nitem, int hilight)
    {
        int baseline = self.menubar.font.getAscent() + 2;
        var items = self.menubar.items;
        var itempos = self.itempos;
        string str = items[nitem].name;
        int x = itempos[nitem];
        self.SetForeground(hilight ? self.hibgcolor : self.bgcolor);
        self.FillRectangle(x - BARSEP / 4, 0,
            self.getTextWidth(str) + BARSEP / 2, self.height);
        self.SetForeground(self.fgcolor);
        self.DrawString(x, baseline, str);
    }
    function onexpose(event)
    {
        int curitem = self.curitem;
        var items = self.menubar.items;
        int n = elements(items);
        for (int i = 0; i < n; ++i)
            self.updateitem(i, i == curitem);
    }
    function onbuttonpress(event)
    {
        if (event.button() != 1)
            return;
        self.active =: true;
        int x = event.x();
        int y = event.y();
        int curitem = self.curitem;

        :( int r, int child_p, int win_x, int win_y) =
                self.querypointer();
        int nitem = (r && child_p == self.getDID()) ?
            self.itemAt(x) :
            CURRENT_NONE;
        if (nitem != CURRENT_NONE && nitem != curitem)
            self.setcurrent(nitem);
    }
    function onbuttonrelease(event)
    {
        int time = event.time();
        self.active =: false;
        var child = self.child;
        if (child != null) {
            int current = child.current;
            if (current != CURRENT_NONE) {
                var action = child.menu.items[current].action;
                self.deactivate(time);
                self.controller.pushaction(action);
            }
            else {
               :( int r, int child_p, int win_x, int win_y) =
                        self.querypointer();
                int nitem = (r && child_p == self.getDID()) ?
                        self.itemAt(event.x()) :
                        CURRENT_NONE;
                if (nitem != CURRENT_NONE) {
                    if (! self.grab)
                        self.grabme(time);
                }
                else
                    self.deactivate(time);
            }
        }
        else
            self.deactivate(time);
    }
    function onmotion(event)
    {
        if (! self.active)
            return;
        :( int r, int child_p, int win_x, int win_y) =
                self.querypointer();
        var child = self.child;
        if (r && child_p != None) {
            int childid = child == null ? None : child.getDID();
            if (child != null && child_p == childid)
                child.setcurrent(win_x - child.x, win_y - child.y);
            else {
                if (child_p == self.getDID()) {
                    int curitem = self.curitem;
                    int nitem = self.itemAt(event.x());
                    if (nitem != CURRENT_NONE && nitem != curitem)
                        self.setcurrent(nitem);
                    else {
                        if (child != null)
                            child.changecurrent(CURRENT_NONE);
                    }
                }
                else {
                    if (child != null)
                        child.changecurrent(CURRENT_NONE);
                }
            }
        }
        else {
            if (child != null)
                child.changecurrent(CURRENT_NONE);
        }
    }
}

class MenuBarItem
{
    var name;
    var action;
    function MenuBarItem(string name, action)
    {
        self.name = name;
        self.action = action;
    }
}

class MenuBar
{
    var display;
    var font;
    var items;
    function MenuBar(display, font)
    {
        self.display = display;
        self.font = font;
        self.items = [];
    }
    function getwidth()
    {
        var items = self.items;
        int n = elements(items);
        if (n == 0)
            return 0;
        var display = self.display;
        var font = self.font;
        int width = BARSEP / 2 + (n - 1) * BARSEP;
        for (int i = 0; i < n; ++i) {
            int w = font.getTextxOff(display, items[i].name);
            width += w;
        }
        return width;
    }
    function getheight()
    {
        return int(self.font.getHeight()) + 8;
    }
    function push(string name, action)
    {
        push(self.items, new MenuBarItem(name, action));
    }
    function activate(parent, int x, int y, int width)
    {
        var window = new MenuBarWindow(parent, x, y, width, self);
        return window;
    }
}

} // namespace Guitor

// End.
