#! winxed

// pokedit - A text editor
// (C) 2011 Juli√°n Albo "NotFound"

$include "Guitor.winxhead";

$load "Guitor.pbc";

using namespace Guitor;
using namespace Guitor.Events;

//**************************************************************

// Convenience functions

// Build a event handler function from object and method name.
// The method is assumed to take a event argument

function eventhandler(object, string methodname)
{
    var method = find_method(object, methodname);
    return function (event)
        {
            object.*method(event);
        };
}

// Bind a object and a method given by name into a invokable

function method_fun(object, string methodname)
{
    var method = find_method(object, methodname);
    return function (args[slurpy])
        {
            return object.*method(args:[flat]);
        };
}

// Some common use atoms

const string
    WM_PROTOCOLS_s     = "WM_PROTOCOLS",
    WM_DELETE_WINDOW_s = "WM_DELETE_WINDOW",
    WM_TAKE_FOCUS_s    = "WM_TAKE_FOCUS",
    UTF8_STRING        = "UTF8_STRING",
    CLIPBOARD          = "CLIPBOARD";

// Special keys
const string 
    CTRL_C = "\x{3}",
    CTRL_Q = "\x{11}",
    CTRL_S = "\x{13}",
    CTRL_V = "\x{16}",
    CTRL_X = "\x{18}";

//**************************************************************

class SelectedText
{
    var startline;
    var startpos;
    var endline;
    var endpos;
    var checked;
    function SelectedText(int line, int pos)
    {
        self.startline = line;
        self.endline = line;
        self.startpos = pos;
        self.endpos = pos;
        self.checked = 0;
    }
    function get()
    {
        return self.startline, self.startpos, self.endline, self.endpos;
    }
    function getordered()
    {
        int stline = self.startline;
        int endline = self.endline;
        int stpos = self.startpos;
        int endpos = self.endpos;
        if (stline < endline || (stline == endline && stpos <= endpos))
            return stline, stpos, endline, endpos;
        else
            return endline, endpos, stline, stpos;
    }
    function isempty()
    {
        return self.startline == self.endline && self.startpos == self.endpos;
    }
    function check(line, pos)
    {
        int checked = 0;
        if (line == self.startline && pos == self.startpos)
            checked = 1;
        else if (line == self.endline && pos == self.endpos)
            checked = 2;
        self.checked =: checked;
    }
    function moveend(int line, int pos)
    {
        self.endline =: line;
        self.endpos =: pos;
    }
    function move(int line, int pos)
    {
        :(int stline, int stpos, int endline, int endpos) = self.get();
        int checked;
        if (self.isempty()) {
            int stline = self.startline;
            if (line < stline || (line == stline && pos < stpos))
                checked = 1;
            else
                checked = 2;
        }
        else
            checked = self.checked;
        switch (checked) {
          case 1:
            stline = line;
            stpos = pos;
            break;
          case 2:
            endline = line;
            endpos = pos;
            break;
          default:
            cry("WARNING: something wrong with selected text");
        }
        if (checked != 0 &&
                (stline > endline || (stline == endline && stpos > endpos))) {
            self.startline =: endline;
            self.endline =: stline;
            self.startpos =: endpos;
            self.endpos =: stpos;
        }
        else {
            self.startline =: stline;
            self.endline =: endline;
            self.startpos =: stpos;
            self.endpos =: endpos;
        }
    }
}

//**************************************************************

class AlertWindow : TopLevelWindow
{
    var text;
    var ascent;
    var lineheight;
    var height;
    var marginleft;
    function AlertWindow(parent, string message)
    {
        var controller = parent.controller;
        var display = controller.display;
        var text = split("\n", message);
        self.text = text;
        var font = display.CreateFont("sans-12");
        int ascent = font.getAscent();
        int lineheight = ascent + font.getDescent();
        int height = lineheight * elements(text);
        int width = 0;
        for (int i = 0, n = elements(text); i < n; ++i) {
            int w = font.getTextxOff(display, text[i]);
            if (w > width)
                width = w;
        }
        width += font.getTextxOff(display, "MMMM");
        self.marginleft = int(font.getTextxOff(display, "MM"));
        self.ascent = ascent;
        self.lineheight = lineheight;
        self.height = height;
        self.TopLevelWindow(parent.controller,
                "Pokedit alert", 0, 0, width, height + lineheight * 3);
        var fgcolor = parent.display.ParseColor("black");
        self.SetForeground(fgcolor);
        var bgcolor = parent.display.ParseColor("white");
        self.SetBackground(bgcolor);
        var button = new TextButton(self, 0, 0, 0, 0, "Ok", font);
        int bwidth = button.getwidth();
        button.OnClick += function () { self.Destroy(); };
        button.MoveWindow((width - bwidth) / 2, height + lineheight);
        button.Map();

        self.SetFont(font);
        self.SetWMProtocols([ WM_DELETE_WINDOW_s ]);
        self.OnClientMessage += eventhandler(self, "onclientmessage");
        self.OnExpose        += eventhandler(self, "onexpose");
        self.SetTransientFor(parent);
    }
    function onclientmessage(event)
    {
        self.Destroy();
    }
    function onexpose(event)
    {
        var text = self.text;
        int ascent = self.ascent;
        int lineheight = self.lineheight;
        int marginleft = self.marginleft;
        for (int i = 0, n = elements(text); i < n; ++i)
            self.DrawImageString(marginleft, i * lineheight + ascent, text[i]);
    }
}

//**************************************************************

class SaveasWindow : ChildWindow
{
    var parent;
    var font;
    var height;
    var edit;
    var bok;
    var bcancel;
    function SaveasWindow(parent, font, int width)
    {
        self.parent = parent;
        self.font = font;
        int height = 24;
        self.height = height;
        var bgcolor = parent.display.ParseColor("RGB:A/A/A");
        self.ChildWindow(parent, 0, 0, parent.width, height,
            { "background-color" : bgcolor } );
        self.SetBackground(bgcolor);
        int editxpos = font.getTextxOff(self.display, "Save as ");

        var bok = new TextButton(self, 0, 0, 0, 0, "Ok", font);
        int bokwidth = bok.getwidth();
        int bheight = bok.getheight();
        bok.MoveResizeWindow(width - bokwidth - 2, (height - bheight) / 2,
                bokwidth, bheight);
        self.bok = bok;
        var bcancel = new TextButton(self, 0, 0, 0, 0, "cancel", font);
        int bcancelwidth = bcancel.getwidth();
        bcancel.MoveResizeWindow(width - bcancelwidth - bokwidth - 4,
                (height - bheight) / 2,
                bcancelwidth, bheight);
        self.bcancel = bcancel;

        int editwidth = width - editxpos - bokwidth - bcancelwidth - 6;
        var edit = new EditBox(self, editxpos, 2, editwidth, 0, font);
        self.edit = edit;
        self.height = 4 + edit.height;

        self.OnExpose += eventhandler(self, "onexpose");
        edit.OnKeyPress += eventhandler(self, "oneditkeypress");
        bok.OnClick += eventhandler(self, "doit");
        bcancel.OnClick += eventhandler(self, "cancel");

        edit.Map();
        bok.Map();
        bcancel.Map();
    }
    function close()
    {
        var bok = self.bok;
        if (bok != null) {
            self.bok = null;
            bok.Destroy();
        }
        var bcancel = self.bcancel;
        if (bcancel != null) {
            self.bcancel = null;
            bcancel.Destroy();
        }
        var edit = self.edit;
        if (edit != null) {
            self.edit = null;
            edit.Destroy();
        }
        self.Destroy();
    }
    function getheight()
    {
        return int(self.height);
    }
    function setfocus()
    {
        var edit = self.edit;
        if (edit != null)
            self.edit.SetInputFocus(RevertToParent);
    }
    function doit(event [optional])
    {
        self.parent.savetofile(self.edit.getValue());
        self.parent.closedialog();
    }
    function cancel(event [optional])
    {
        self.parent.closedialog();
    }
    function onexpose(event)
    {
        self.SetFont(self.font);
        self.DrawImageString(2, 18, "Save as");
    }
    function oneditkeypress(event)
    {
        switch (event.keyname()) {
          case "Escape":
            self.cancel();
            break;
          case "Return":
            self.doit();
            break;
        }
    }
}

//**************************************************************

class StatusWindow : ChildWindow
{
    var parent;
    var ascent;
    var descent;
    var fgcolor;
    var bgcolor;
    var height;
    var nwidth;
    function StatusWindow(parent, int x, int y, int width, int height, font)
    {
        self.parent = parent;
        self.fgcolor = parent.display.ParseColor("grey50");
        self.bgcolor = parent.display.ParseColor("grey95");
        int ascent = font.getAscent();
        int descent = font.getDescent();
        height = ascent + descent;
        self.ascent = ascent;
        self.descent = descent;
        self.height = height;
        self.ChildWindow(parent, x, y, width, height,
                { "background-color": self.bgcolor } );
        self.SetForeground(self.fgcolor);
        self.SetBackground(self.bgcolor);
        self.SetFont(font);
        self.nwidth = int(self.getTextxOff("MMMM"));
        self.OnExpose           += eventhandler(self, "onexpose");
    }
    function getheight()
    {
        return int(self.height);
    }
    function onexpose(event)
    {
        self.updatepos();
    }
    function updatepos()
    {
        var tw = self.parent.textwindow;
        int curpos = tw.curpos + 1;
        int curline = tw.curline + 1;
        int nwidth = self.nwidth;
        int ascent = self.ascent;
        int descent = self.descent;
        self.SetForeground(self.bgcolor);
        self.FillRectangle(0, 0, nwidth * 3, ascent + descent);
        self.SetForeground(self.fgcolor);
        self.DrawString(0, ascent, curpos);
        self.DrawString(nwidth * 2, ascent, curline);
    }
}

//**************************************************************

class TextWindow : ChildWindow
{
    const int MARGINSUP = 4;
    const int MARGINLEFT = 2;
    var parent;
    var textfont;
    var fgcolor;
    var bgcolor;
    var width;
    var height;
    var lineheight;
    var ascent;
    var text;
    var headline;
    var maxlines;
    var xoff;
    var curline;
    var curpos;
    var has_focus;
    var selected;
    var copybuffer;
    var pressed;

    function TextWindow(parent, int x, int y, int width, int height, font)
    {
        self.parent = parent;
        string text[];
        self.text = text;
        self.textfont = font;
        self.width = width;
        self.height = height;
        int ascent = font.getAscent();
        int descent = font.getDescent();
        int lineheight = ascent + descent;
        self.lineheight = lineheight;
        self.ascent = ascent;
        self.headline = 0;
        self.maxlines = int((height - MARGINSUP) / lineheight);
        self.xoff = MARGINLEFT;
        self.curline = 0;
        self.curpos = 0;
        self.has_focus = false;
        self.pressed = false;
        self.ChildWindow(parent, x, y, width, height);
        self.SetFont(font);
        self.fgcolor = self.display.ParseColor("black");
        self.bgcolor = self.display.ParseColor("white");
        self.SetForeground(self.fgcolor);
        self.SetBackground(self.bgcolor);

        self.OnDestroy          += eventhandler(self, "ondestroy");
        self.OnConfigure        += eventhandler(self, "onconfigure");
        self.OnExpose           += eventhandler(self, "onexpose");
        self.OnFocusIn          += eventhandler(self, "onfocusin");
        self.OnFocusOut         += eventhandler(self, "onfocusout");
        self.OnKeyPress         += eventhandler(self, "onkeypress");
        self.OnButtonPress      += eventhandler(self, "onbuttonpress");
        self.OnButtonRelease    += eventhandler(self, "onbuttonrelease");
        self.OnMotion           += eventhandler(self, "onmotion");
        self.OnSelectionClear   += eventhandler(self, "onselectionclear");
        self.OnSelectionRequest += eventhandler(self, "onselectionrequest");
        self.OnSelectionNotify  += eventhandler(self, "onselectionnotify");
    }
    function ondestroy(event)
    {
        self.text = null;
        self.parent.close();
    }
    function onconfigure(event)
    {
        int width = event.width();
        int height = event.height();
        self.width =: width;
        self.height =: height;
        int lineheight = self.lineheight;
        self.maxlines =: int((height - MARGINSUP) / lineheight);
        if (self.text != null) {
            self.adjust();
            self.checkxoff();
        }
    }
    function onexpose(event)
    {
        if (self.text != null) {
            self.drawall();
            self.invertselection();
            self.cursor();
        }
    }
    function onfocusin(event)
    {
        if (self.text == null)
            return;
        int detail = event.detail();
        self.has_focus =: true;
        self.cursor();
    }
    function onfocusout(event)
    {
        if (self.text == null)
            return;
        int detail = event.detail();
        self.cursor();
        self.has_focus =: false;
    }
    function onkeypress(event)
    {
        var text = self.text;
        int headline = self.headline;
        int curline = self.curline;
        int curpos = self.curpos;
        int l;
        string key = event.keyname();
        self.cursor();

        int drawall = false;
        int shifted = (event.state() & ShiftMask) != 0;
        if (shifted)
            self.checkselected(curline, curpos);
        switch (key) {
          case "Prior":
            if (! shifted)
                self.cancelselected();
            if (curline > 0) {
                l = self.maxlines - 1;
                curline -= l;
                if (curline < 0)
                    curline = 0;
                self.curline =: curline;
                if (headline > 0) {
                    headline -= l;
                    if (headline < 0)
                        headline = 0;
                    self.headline =: headline;
                    drawall = true;
                }
            }
            break;
          case "Next":
            if (! shifted)
                self.cancelselected();
            int nlines = elements(text);
            if (curline < nlines) {
                l = self.maxlines - 1;
                curline += l;
                if (curline > nlines)
                    curline = nlines;
                self.curline =: curline;
                if (headline < nlines) {
                    headline += l;
                    if (headline > nlines)
                        headline = nlines;
                    self.headline =: headline;
                    drawall = true;
                }
            }
            break;
          case "Up":
            if (! shifted)
                self.cancelselected();
            if (curline > 0)
                if (self.moveup())
                    drawall = true;
            if (self.checkxoff())
                drawall = true;
            break;
          case "Down":
            if (! shifted)
                self.cancelselected();
            if (curline < elements(text))
                if (self.movedown())
                    drawall = true;
            if (self.checkxoff())
                drawall = true;
            break;
          case "Home":
            if (! shifted)
                self.cancelselected();
            curpos = 0;
            self.curpos =: curpos;
            if (event.state() & ControlMask) {
                self.curline =: 0;
                self.headline =: 0;
                drawall = true;
            }
            if (self.checkxoff())
                drawall = true;
            break;
          case "End":
            if (! shifted)
                self.cancelselected();
            if (event.state() & ControlMask) {
                self.curpos =: 0;
                l = elements(text);
                self.curline =: l;
                l = l - self.maxlines + 1;
                if (l < 0)
                    l = 0;
                if (l > headline) {
                    self.headline =: l;
                    drawall = true;
                }
            }
            else {
                curpos = length(text[curline]);
                self.curpos =: curpos;
            }
            if (self.checkxoff())
                drawall = true;
            break;
          case "Left":
            if (! shifted)
                self.cancelselected();
            l = length(text[curline]);
            if (curpos > l)
                self.curpos =: curpos = l;
            if (curpos == 0) {
                if (curline == 0)
                    break;
                if (self.moveup())
                    drawall = true;
                curline = self.curline;
                curpos = length(text[curline]);
            }
            else {
                --curpos;
            }
            self.curpos =: curpos;
            if (self.checkxoff())
                drawall = true;
            break;
          case "Right":
            if (! shifted)
                self.cancelselected();
            int maxpos = length(text[curline]);
            if (++curpos > maxpos) {
                if (curline >= elements(text))
                    break;
                if (self.movedown())
                    drawall = true;
                curpos = 0;
            }
            self.curpos =: curpos;
            if (self.checkxoff())
                drawall = true;
            break;
          case "BackSpace":
            if (self.someselected()) {
                self.deleteselected();
                drawall = true;
                break;
            }
            l = length(text[curline]);
            if (curpos > l)
                self.curpos =: curpos = l;
            if (curpos > 0) {
                string line = text[curline];
                if (substr(line, 0, curpos) == " " * curpos) {
                    if (curpos < 4) {
                    }
                    else {
                        line = substr(line, 4);
                        curpos -= 4;
                    }
                }
                else {
                    --curpos;
                    line = substr(line, 0, curpos) + substr(line, curpos + 1);
                }
                self.curpos =: curpos;
                text[curline] = line;
                self.drawline(curline);
            }
            else if (curline > 0) {
                if (curline < elements(text)) {
                    string line = text[curline];
                    delete text[curline];
                    string prevline = text[curline - 1];
                    curpos = length(prevline);
                    line = prevline + line;
                    text[curline - 1] = line;
                }
                else
                    curpos = length(text[curline - 1]);
                --curline;
                self.curline =: curline;
                self.curpos =: curpos;
                drawall = true;
            }
            break;
          case "Delete":
            if (self.someselected()) {
                self.deleteselected();
                drawall = true;
                break;
            }
            l = length(text[curline]);
            if (curpos > l)
                self.curpos =: curpos = l;
            if (curpos < l) {
                string line = text[curline];
                line = substr(line, 0, curpos) + substr(line, curpos + 1);
                text[curline] = line;
                self.drawline(curline);
            }
            else if (curline < elements(text)) {
                string line = text[curline + 1];
                delete text[curline + 1];
                string prevline = text[curline];
                curpos = length(prevline);
                line = prevline + line;
                text[curline] = line;
                self.curpos =: curpos;
                drawall = true;
            }
            break;
          default:
            key = self.LookupString(event);
            if (key == null || length(key) == 0)
                 break;
            string line = text[curline];
            l = length(line);
            switch (key) {
              case "\r":
                self.cancelselected();
                if (curpos > l)
                    curpos = l;
                string newline = substr(line, curpos);
                int ind;
                for (ind = 0; ind < curpos && line[ind] == ' '; ++ind)
                    ;
                line = substr(line, 0, curpos);
                for (int i = elements(text); i > curline; --i)
                    text[i] = text[i - 1];
                text[curline] = line;
                if (ind)
                    newline = " " * ind + newline;
                text[curline + 1] = newline;
                self.curpos =: ind;
                if (! self.movedown())
                    self.drawlines(curline, 0);
                break;
              case CTRL_Q:
                self.parent.close();
                return;
              case CTRL_S:
                self.parent.save();
                return;
              case CTRL_C:
                self.copyselected(event.time());
                break;
              case CTRL_X:
                self.cutselected(event.time());
                return;
              case CTRL_V:
                if (self.someselected())
                    self.cancelselected();
                self.paste(event.time());
                break;
              case "\t":
                // Cheap trick
                if (curpos > l)
                    curpos = l;
                key = " " * (4 - (curpos % 4));
              default:
                self.cancelselected();
                if (ord(key) < ord(" "))
                    break;
                if (self.someselected())
                    self.cancelselected();
                if (curpos > l)
                    curpos = l;
                line = substr(line, 0, curpos) + key + substr(line, curpos);
                curpos += length(key);
                text[curline] = line;
                self.curpos =: curpos;
                self.drawline(curline);
            }
        }
        if (drawall)
            self.drawall();
        if (shifted)
            self.moveselected();
        self.parent.updatepos();
        self.cursor();
    }
    function onbuttonpress(event)
    {
        switch (event.button()) {
          case 1:
            self.cursor();
            int x = event.x();
            int y = event.y();
            var text = self.text;
            int l = self.getline(y);
            int pos;
            if (l < elements(text))
                pos = self.getpos(x, l);
            else 
                pos = 0;
            self.cancelselected();
            self.selected = new SelectedText(l, pos);
            self.pressed =: 1;
            self.curpos =: pos;
            self.curline =: l;
            self.parent.updatepos();
            self.cursor();
            break;
          case 2:
            // Paste primary selection - unfinished
            var display = self.display;
            display.ConvertSelection(XA_PRIMARY,
                    self.InternAtom(UTF8_STRING),
                    XA_PRIMARY, self, event.time());
            break;
          case 4:
            if (self.up()) {
                self.cursor();
                self.invertselection();
                self.drawall();
                self.invertselection();
                self.cursor();
            }
            break;
          case 5:
            if (self.down()) {
                self.cursor();
                self.invertselection();
                self.drawall();
                self.invertselection();
                self.cursor();
            }
            break;
        }
    }
    function onbuttonrelease(event)
    {
        int pressed = self.pressed;
        self.pressed =: 0;
        var selected = self.selected;
        switch (pressed) {
          case 1:
            if (selected != null) {
                if (selected.isempty())
                    self.selected = null;
                else
                    self.SetSelectionOwner(XA_PRIMARY, event.time());
            }
            break;
        }
    }
    function onmotion(event)
    {
        if (self.text == null)
            return;
        if (self.pressed == 1)
        {
            self.cursor();
            int x = event.x();
            int y = event.y();
            var text = self.text;
            int l = self.getline(y);
            int pos;
            if (l < elements(text))
                pos = self.getpos(x, l);
            else 
                pos = 0;
            self.invertselection();
            self.selected.moveend(l, pos);
            int headline = self.headline;
            int lineheight = self.lineheight;
            int maxlines = self.maxlines;
            if (l >= headline + maxlines) {
                int desp = l - headline - maxlines + 1;
                int ny = y - desp * lineheight;
                self.display.WarpPointer(self.getDID(), x, ny);
                self.headline = headline + desp;
                self.drawall();
            }
            else if (l < headline) {
                int desp = headline - l;
                int ny = y + desp * lineheight;
                self.display.WarpPointer(self.getDID(), x, ny);
                self.headline = headline - desp;
                self.drawall();
            }
            self.curpos =: pos;
            self.curline =: l;
            self.invertselection();
            self.parent.updatepos();
            self.cursor();
        }
    }
    function getline(int y)
    {
        // Get the text line at the y coordninate
        var text = self.text;
        int nlines = elements(text);
        int headline = self.headline;
        int lineheight = self.lineheight;
        int l = (y - MARGINSUP) / lineheight + headline;
        if (l < 0)
            l = 0;
        if (l > nlines)
            l = nlines;
        return l;
    }
    function getpos(int x, int nline)
    {
        // Get the chcaracet position at the x coordinate
        x -= self.xoff;
        if (x < 0)
            return 0;
        var text = self.text;
        string line = text[nline];
        int rp = length(line);
        if (rp == 0)
            return 0;
        if (x > self.getTextxOff(line))
            return rp;
        int lp = 0;
        int mp;
        while ((mp = (lp + rp) / 2) != lp) {
            if (x < self.getTextxOff(substr(line, 0, mp)))
                rp = mp;
            else
                lp = mp;
        }
        return x < ((self.getTextxOff(substr(line, 0, mp)) +
                     self.getTextxOff(substr(line, 0, mp + 1))) / 2) ?
                     mp : mp + 1;
    }
    function onselectionclear(event)
    {
        int selection = event.selection();
        if (selection != XA_PRIMARY)
            return;
        self.cancelselected();
    }
    function onselectionrequest(event)
    {
        int requestor = event.requestor();
        int selection = event.selection();
        int target = event.target();
        int property = event.property();
        var display = self.display;

        string targetname = self.GetAtomName(target);
        int typeutf8 = self.InternAtom("UTF8_STRING");
        // Request for supported types: answer only utf8 text.
        if (targetname == "TARGETS") {
            display.ChangePropertyInt32(requestor,
                    property, target, PropModeReplace, typeutf8);
        }
        else if (target == typeutf8 || target == XA_STRING) {
            // Request for text: fine, do it.
            var copybuffer = self.copybuffer;
            string textsel = copybuffer == null ? "" : copybuffer;
            // Some clients can request STRING without checking.
            // Try to transcode in that case.
            if (target == XA_STRING) {
                try {
                    textsel = trans_encoding(textsel, "iso-8859-1");
                    display.ChangePropertyStringIso(requestor,
                            property, target, PropModeReplace, textsel);
                }
                catch () { }
            }
            else
                display.ChangePropertyString(requestor,
                        property, target, PropModeReplace, textsel);
        }
        else
            return;

        var notify = new Event(SelectionNotify);
        // No much support for creating events yet, use the
        // raw StructView for a now.
        var data = notify.eventdata;
        var view = notify.getview();
        view[data, 4] = requestor;
        view[data, 5] = selection;
        view[data, 6] = target;
        view[data, 7] = property;
        view[data, 8] = event.time();
        display.SendEvent(requestor, false, 0, notify);
    }
    function onselectionnotify(event)
    {
        var display = self.display;
        int selection = event.selection();
        int target = event.target();
        int property = event.property();
        if (property == None) {
            if (target == self.InternAtom("UTF8_STRING")) {
                // Retry with plain string type
                display.ConvertSelection(selection, XA_STRING,
                        selection, self, event.time());
            }
            return;
        }
        string pasted;
        if (target == XA_STRING)
            pasted = self.GetPropertyString(property);
        else
            pasted = self.GetPropertyUtf8String(property);
        if (pasted == null)
            return;
        int lenpasted = length(pasted);
        if (lenpasted == 0)
            return;
        self.cursor();
        int curline = self.curline;
        int curpos = self.curpos;
        var text = self.text;
        string line = text[curline];
        int l = length(line);
        if (curpos > l)
            curpos = l;
        int pos = indexof(pasted, "\n");
        if (pos < 0) {
            line = substr(line, 0, curpos) + pasted + substr(line, curpos);
            curpos += length(pasted);
            text[curline] = line;
            self.curpos =: curpos;
            if (self.checkxoff())
                self.drawall();
            else
                self.drawline(curline);
        }
        else {
            int fpos = pos;
            string plines[];
            int npos;
            while ((npos = indexof(pasted, "\n", pos + 1)) >= 0) {
                string l = substr(pasted, pos + 1, npos - pos - 1);
                push(plines, l);
                pos = npos;
            }
            int nplines = elements(plines);
            string firstline = substr(line, 0, curpos) +
                    substr(pasted, 0, fpos);
            string lastline = substr(pasted, pos + 1);
            self.curpos =: length(lastline);
            lastline += substr(line, curpos);
            for (int i = elements(text); i > curline; --i)
                text[i + nplines + 1] = text[i];
            for (int i = 0; i < nplines; ++i)
                text[curline + i + 1] = plines[i];
            text[curline] = firstline;
            text[curline + nplines + 1] = lastline;
            int oldcurline = curline;
            self.curline =: curline + nplines + 1;
            if (self.adjust() || self.checkxoff())
                self.drawall();
            else
                self.drawlines(oldcurline, 0);
        }
        self.parent.updatepos();
        self.cursor();
    }
    function getselectedtext()
    {
        var selected = self.selected;
        if (selected == null || selected.isempty())
            return "";
        :(int stline, int stpos, int endline, int endpos) =
            selected.getordered();
        var text = self.text;
        string firstline = text[stline];
        string result;
        if (stline == endline)
             result = substr(firstline, stpos, endpos - stpos);
        else {
             result = substr(firstline, stpos);
             for (int l = stline + 1; l < endline; ++l) {
                 result += "\n";
                 result += string(text[l]);
             }
             result += "\n";
             result += substr(text[endline], 0, endpos);
        }
        return result;
    }
    function someselected()
    {
        var selected = self.selected;
        return selected != null && ! selected.isempty();
    }
    function deleteselected()
    {
        var selected = self.selected;
        if (selected == null || selected.isempty())
            return;
        :(int stline, int stpos, int endline, int endpos) =
            selected.getordered();
        var text = self.text;
        string firstline = text[stline];
        string lastline = text[endline];
        string line = substr(firstline, 0, stpos) + substr(lastline, endpos);
        text[stline] = line;
        for (int l = stline + 1; l < endline; ++l)
            delete text[stline + l];
        self.selected = null;
        self.curline =: stline;
        self.curpos =: stpos;
        self.adjust();
    }
    function cancelselected()
    {
        var selected = self.selected;
        if (selected != null) {
            self.invertselection();
            self.selected = null;
        }
    }
    function checkselected(int line, int pos)
    {
        var selected = self.selected;
        if (selected == null)
            self.selected = selected = new SelectedText(line, pos);
        else
            self.invertselection();
        selected.check(line, pos);
    }
    function invertselection()
    {
        if (self.text == null)
            return;
        var selected = self.selected;
        if (selected == null || selected.isempty())
            return;
        :(int stline, int stpos, int endline, int endpos) =
            selected.getordered();
        var text = self.text;
        int headline = self.headline;
        int lineheight = self.lineheight;
        int maxlines = self.maxlines;
        int firstline = stline;
        int lastline = headline + maxlines - 1;

        if (firstline < headline)
            firstline = headline;
        if (lastline > endline)
           lastline = endline;
        self.SetFunction(GXinvert);
        int xoff = self.xoff;
        for (int nline = firstline; nline <= lastline; ++nline) {
            string line = nline >= elements(text) ? "" : self.text[nline];
            int ascent = self.ascent;
            int ypos = MARGINSUP + lineheight * (nline - headline);
            int pos0 = nline == stline ? stpos : 0;
            int pos1 = nline == endline ? endpos : length(line);
            int x0 = pos0 == 0 ? 0 : self.getTextxOff(substr(line, 0, pos0));
            int x1 = pos1 == 0 ? 0 : self.getTextxOff(substr(line, 0, pos1));

            self.FillRectangle(x0 + xoff, ypos, x1 - x0, lineheight);
        }
        self.SetFunction(GXcopy);
    }
    function moveselected()
    {
        var selected = self.selected;
        if (selected != null) {
            selected.move(self.curline, self.curpos);
            self.invertselection();
            self.SetSelectionOwner(XA_PRIMARY, CurrentTime);
        }
    }
    function paste(int time)
    {
        int clipboard = self.InternAtom(CLIPBOARD);
        self.display.ConvertSelection(clipboard, self.InternAtom(UTF8_STRING),
                clipboard, self, time);
    }
    function cutselected(int time)
    {
        if (self.selected == null)
            self.parent.alert("Nothing to cut");
        else {
            self.cursor();
            self.invertselection();
            string text = self.getselectedtext();
            self.copybuffer = text;
            self.deleteselected();
            self.drawall();
            self.parent.updatepos();
            self.cursor();
            self.SetSelectionOwner(self.InternAtom(CLIPBOARD), time);
        }
    }
    function copyselected(int time)
    {
        if (self.selected == null)
            self.parent.alert("Nothing to copy");
        else {
            string text = self.getselectedtext();
            self.copybuffer = text;
            self.SetSelectionOwner(self.InternAtom(CLIPBOARD), time);
        }
    }
    function checkxoff()
    {
        var text = self.text;
        if (text == null)
            return;
        int curline = self.curline;
        int curpos = self.curpos;
        int width = self.width;
        int xoff = self.xoff;
        string line = text[curline];
        int xpos = self.getTextxOff(substr(line, 0, curpos));
        if (xpos >= width - xoff) {
            int chunk = (width - MARGINLEFT) / 3;
            xoff = MARGINLEFT - (int(xpos/ chunk) - 1) * chunk;
            self.xoff =: xoff;
            return true;
        }
        if (xpos + xoff < 0) {
            int chunk = (width - MARGINLEFT) / 3;
            xoff = MARGINLEFT - int(xpos/ chunk) * chunk;
            self.xoff =: xoff;
            return true;
        }
        return false;
    }
    function adjust()
    {
        int height = self.height;
        int lineheight = self.lineheight;
        int headline = self.headline;
        int maxlines = self.maxlines;
        int lastline = headline + maxlines;
        int curline = self.curline;
        if (curline >= lastline) {
            self.headline =: curline - maxlines + 1;
            return true;
        }
        else if (curline < headline) {
            self.headline =: curline;
            return true;
        }
        else
            return false;
    }
    function up()
    {
        int headline = self.headline;
        if (headline > 0) {
            self.scrollup();
            return true;
        }
        else
            return false;
    }
    function down()
    {
        int height = self.height;
        int lineheight = self.lineheight;
        int headline = self.headline;
        int nlines = elements(self.text);
        if (headline < nlines) {
            self.scrolldown();
            return true;
        }
        else
            return false;
    }
    function moveup()
    {
        int curline = self.curline;
        --curline;
        self.curline =: curline;
        int headline = self.headline;
        if (headline > curline) {
            self.scrollup();
            return true;
        }
        else
            return false;
    }
    function movedown()
    {
        int curline = self.curline;
        ++curline;
        self.curline = curline;
        int height = self.height;
        int lineheight = self.lineheight;
        int headline = self.headline;
        int maxlines = self.maxlines;
        if (curline >= headline + maxlines) {
            self.scrolldown();
            return true;
        }
        else
            return false;
    }
    function scrollup()
    {
        int headline = self.headline;
        --headline;
        self.headline =: headline;
        //self.drawall();
    }
    function scrolldown()
    {
        int headline = self.headline;
        ++headline;
        self.headline =: headline;
        //self.drawall();
    }
    function cursor()
    {
        if (! self.has_focus)
            return;
        var text = self.text;
        if (text == null)
            return;
        int curline = self.curline;
        int headline = self.headline;
        int maxlines = self.maxlines;
        if (curline < headline || curline >= headline + maxlines)
            return;

        int lineheight = self.lineheight;
        int ypos = (curline - headline) * lineheight + MARGINSUP;
        string line = text[curline];
        int curpos = self.curpos;
        int xpos = self.getTextxOff(substr(line, 0, curpos)) + self.xoff;
        self.SetFunction(GXinvert);
        self.FillRectangle(xpos, ypos, 2, lineheight);
        self.SetFunction(GXcopy);
    }
    function drawall()
    {
        int headline = self.headline;
        int maxlines = self.maxlines;
        int maxline = headline + maxlines - 1;
        self.drawlines(headline, maxline);
    }
    function drawlines(int from, int to)
    {
        int headline = self.headline;
        int maxlines = self.maxlines;
        int maxline = headline + maxlines - 1;
        if (from < headline)
            from = headline;
        if (to == 0)
            to =  maxline;
        else if (to > maxline)
            to = maxline;
        for (int line = from; line <= to; ++line)
            self.drawline(line);
    }
    function drawline(int nline)
    {
        var text = self.text;
        string line;
        if (nline < elements(text))
            line = self.text[nline];
        int headline = self.headline;
        int lineheight = self.lineheight;
        int ascent = self.ascent;
        int ypos = MARGINSUP + lineheight * (nline - headline);
        self.SetForeground(self.bgcolor);
        self.FillRectangle(0, ypos, self.width, lineheight);
        self.SetForeground(self.fgcolor);
        if (line != null)
            self.DrawString(self.xoff, ypos + ascent, line);
    }
    function set(text)
    {
        self.text = text;
    }
    function indent()
    {
        var selected = self.selected;
        if (selected == null || selected.isempty())
            return "";
        self.cursor();
        self.invertselection();
        :(int stline, int stpos, int endline, int endpos) =
            selected.getordered();
        var text = self.text;
        for (int l = stline; l <= endline; ++l) {
            string line = text[l];
            if (length(line) > 0) {
                line = "    " + line;
                text[l] = line;
            }
        }
        self.drawlines(stline, endline);
        self.invertselection();
        self.cursor();
    }
    function unindent()
    {
        var selected = self.selected;
        if (selected == null || selected.isempty())
            return "";
        self.cursor();
        self.invertselection();
        :(int stline, int stpos, int endline, int endpos) =
            selected.getordered();
        var text = self.text;
        for (int l = stline; l <= endline; ++l) {
            string line = text[l];
            if (substr(line, 0, 4) == "    ") {
                line = substr(line, 4);
                text[l] = line;
            }
        }
        self.drawlines(stline, endline);
        self.invertselection();
        self.cursor();
    }
    function close()
    {
        self.text = null;
        self.Destroy();
    }
}

//**************************************************************

class PokeditWindow : TopLevelWindow
{
    var width;
    var height;
    var menubarh;
    var menubarw;
    var textfont;
    var statusfont;
    var textwindow;
    var statuswindow;
    var dialogwindow;
    var filename;
    function PokeditWindow(controller)
    {
        int width = 800;
        int height = 600;
        self.width = width;
        self.height = height;
        var bgcolor = controller.display.ParseColor("grey70");
        self.TopLevelWindow(controller, "Pokedit", 0, 0, width, height,
                { "background-color" : bgcolor } );
        var display = self.display;
        var menufont = display.CreateFont("sans-12");
        self.textfont = display.CreateFont("mono-10");
        self.statusfont = display.CreateFont("mono-10");

        self.SetWMProtocols( [ WM_DELETE_WINDOW_s, WM_TAKE_FOCUS_s ] );

        self.OnConfigure     += eventhandler(self, "onconfigure");
        self.OnMap           += eventhandler(self, "onmap");
        self.OnClientMessage += eventhandler(self, "onclientmessage");

        var menubar = new MenuBar(display, menufont);
        var filemenu = new Menu(display, menufont);
        filemenu.push("save", method_fun(self, "save") );
        filemenu.push("save as", method_fun(self, "saveas") );
        filemenu.push("close", method_fun(self, "close") );
        var editmenu = new Menu(display, menufont);
        editmenu.push("cut", method_fun(self, "cut") );
        editmenu.push("copy", method_fun(self, "copy") );
        editmenu.push("paste", method_fun(self, "paste") );
        var viewmenu = new Menu(display, menufont);
        viewmenu.push("status", method_fun(self, "togglestatus") );
        var toolsmenu = new Menu(display, menufont);
        toolsmenu.push("indent", method_fun(self, "indent") );
        toolsmenu.push("unindent", method_fun(self, "unindent") );

        menubar.push("File", filemenu);
        menubar.push("Edit", editmenu);
        menubar.push("View", viewmenu);
        menubar.push("Tool", toolsmenu);
        int menubarh = menubar.getheight();
        self.menubarh = menubarh;
        var menubarw = menubar.activate(self, 0, 0, width);
        self.menubarw = menubarw;

        var statuswindow = new StatusWindow(self, 1, height - 24 - 1, 
                width - 2, 24, self.statusfont);
        self.statuswindow = statuswindow;

        var textwindow = new TextWindow(self, 1, menubarh + 1,
                width - 2, height - menubarh - 2 - 24 - 1, self.textfont);
        self.textwindow = textwindow;
        self.configuresubwindows();
        menubarw.Map();
    }
    function configuresubwindows()
    {
        int width = self.width;
        int height = self.height;
        int menubarh = self.menubarh;
        self.menubarw.ResizeWindow(width, menubarh);
        int nextypos = menubarh + 1;
        int textheight = height - menubarh - 2;

        var dialogwindow = self.dialogwindow;
        if (dialogwindow != null) {
            int dheight = dialogwindow.getheight();
            dialogwindow.MoveResizeWindow(1, nextypos, width - 2, dheight);
            nextypos += dheight + 2;
            textheight -= dheight + 2;
        }

        var statuswindow = self.statuswindow;
        if (statuswindow != null) {
            int stheight = statuswindow.getheight();
            textheight -= stheight + 1;
            statuswindow.MoveResizeWindow(1, textheight + nextypos + 1,
                    width - 2, stheight);
        }
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.MoveResizeWindow(1, nextypos, width - 2, textheight);
    }
    function onconfigure(event)
    {
        int width = event.width();
        int height = event.height();
        self.width = width;
        self.height = height;
        self.configuresubwindows();
    }
    function onmap(event)
    {
        if (self.textwindow != null)
            self.textwindow.Map();
        if (self.statuswindow != null)
            self.statuswindow.Map();
    }
    function onclientmessage(event)
    {
        string type = self.GetAtomName(event.message_type());
        switch (type) {
          case WM_PROTOCOLS_s:
            string protocol = self.GetAtomName(event.message_data(0));
            switch (protocol) {
              case WM_DELETE_WINDOW_s:
                self.controller.pushaction(method_fun(self, "close"));
                break;
              case WM_TAKE_FOCUS_s:
                var dialogwindow = self.dialogwindow;
                if (dialogwindow != null) {
                    dialogwindow.setfocus();
                    break;
                }
                var textwindow = self.textwindow;
                if (textwindow != null)
                    textwindow.SetInputFocus(RevertToParent);
                else
                    self.SetInputFocus(RevertToParent);
                break;
              default:
                cry("Warning: unknown WM Protocol: ", protocol);
            }
            break;
          default:
            cry("Warning: unknown ClientMessage type: ", type);
        }
    }

    function openfile(string filename)
    {
        var file = open(filename, "r");
        file.encoding("utf8");
        string lines[];
        string line;
        for (;;) {
            line = file.readline();
            if (file.eof())
                break;
            line = chomp(line);
            push(lines, line);
        }
        if (line != "") {
            push(lines, line);
            cry("Warning: no newline at end of file");
        }
        file.close();
        self.filename = filename;
        self.textwindow.set(lines);
    }
    function closedialog()
    {
        var dialogwindow = self.dialogwindow;
        if (dialogwindow != null) {
            self.dialogwindow = null;
            dialogwindow.close();
            self.controller.pushaction(method_fun(self, "configuresubwindows"));
        }
    }
    function savetofile(string sfile)
    {
        var text = self.textwindow.text;
        try {
            var handle = open(sfile, "w");
            handle.encoding("utf8");
            handle.print(join("\n", text));
            // Check for newline at end of file:
            // avoid adding spurious newllines or leaving non terminated
            // lines at end.
            string last = text[-1];
            if (length(last) != 0)
                handle.print("\n");
            handle.close();
            self.filename = sfile;
        }
        catch (e) {
            self.alert("Error saving file '" + sfile + "':\n" +
                    string(e["message"]));
        }
    }
    function saveas()
    {
        self.dialogwindow = new SaveasWindow(self, self.statusfont, self.width - 2);
        self.configuresubwindows();
        self.dialogwindow.Map();
        self.dialogwindow.setfocus();
    }
    function save()
    {
        var filename = self.filename;
        if (filename == null)
            self.saveas();
        else
            self.savetofile(filename);
    }
    function close()
    {
        var dialogwindow = self.dialogwindow;
        if (dialogwindow != null) {
            self.dialogwindow = null;
            dialogwindow.close();
            self.controller.pushaction(method_fun(self, "close"));
            return;
        }
        var menubarw = self.menubarw;
        if (menubarw != null) {
            self.menubarw = null;
            menubarw.Destroy();
        }
        // If the text window is still here, destroy it.
        // Its OnDentroy handler will call this method again.
        // In the following call, destroy self.
        var textwindow = self.textwindow;
        if (textwindow != null) {
            self.textwindow = null;
            self.controller.pushaction(method_fun(textwindow, "close"));
        }
        else
            self.Destroy();
    }
    function togglestatus()
    {
        var statuswindow = self.statuswindow;
        if (statuswindow == null) {
            statuswindow = new StatusWindow(self, 1, 1,  1, 1,
                    self.statusfont);
            self.statuswindow = statuswindow;
        }
        else {
            self.statuswindow = null;
            statuswindow.Destroy();
            statuswindow = null;
        }
        self.configuresubwindows();
        if (statuswindow != null)
            statuswindow.Map();
    }
    function updatepos()
    {
        var statuswindow = self.statuswindow;
        if (statuswindow != null)
            statuswindow.updatepos();
    }
    function cut()
    {
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.cutselected(CurrentTime);
    }
    function copy()
    {
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.copyselected(CurrentTime);
    }
    function paste()
    {
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.paste(CurrentTime);
    }
    function indent()
    {
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.indent();
    }
    function unindent()
    {
        var textwindow = self.textwindow;
        if (textwindow != null)
            textwindow.unindent();
    }
    function alert(string message)
    {
        var alertw = new AlertWindow(self, message);
        alertw.Map();
    }
}

//**************************************************************

class PokeditController : Controller
{
    function PokeditController()
    {
        self.Controller();
    }
    function pokeditnew()
    {
        var pokedit = new PokeditWindow(self);
        pokedit.OnDestroy += function (event) { self.pokeditclosed(pokedit); };
        pokedit.Map();
    }
    function pokeditopen(string filename)
    {
        var pokedit = new PokeditWindow(self);
        pokedit.openfile(filename);
        pokedit.OnDestroy += function (event) { self.pokeditclosed(pokedit); };
        pokedit.Map();
    }
    function pokeditclosed(window)
    {
        self.pushaction(method_fun(self, "Quit"));
    }
}

//**************************************************************

function main [main] (args)
{
    var controller = new PokeditController();
    if (elements(args) > 1)
        controller.pokeditopen(args[1]);
    else
        controller.pokeditnew();
    controller.MainLoop();
    controller.Close();
}

// End

